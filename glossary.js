// glossaryファイル Node
`use strict`
const glossary = [
{target:`CommonJS modules`, content:`JavaScriptでモジュールを扱うための仕様の一つで、特にNode.js環境で広く使用。<br>モジュールの分割や再利用を容易にする。比較的早く普及したため、npm等ですでに公開されているモジュールの多くで採用。拡張子に.js、.cjsを使用。<br>const fs = require('fs');`},
{target:`exports`, content:`CommonJS modulesのキーワード。ファイル単位に自動的に生成される変数に代入することで、関数や変数を外部に公開可能。<br>module.exportsと併用できない。<br>calc.js<br>***.num = 1;<br>***.add = (a, b) => a + b;<br>index.js<br>const calc = require('./calc');<br>console.log(calc.num); → 1<br>let res = calc.add(3, 1); → 4 `},
{target:`require`, content:`CommonJS modulesのキーワード。モジュールを読み込む。パスを指定して読み込む場合.jsを省略可能。<br>分割代入も可能。<br>calc.js<br>exports.num = 1;<br>exports.add = (a, b) => a + b;<br>index.js<br>const calc = ***('./calc');<br>console.log(calc.num); → 1<br>let res = calc.add(3, 1); → 4<br>const { add } = ***('./calc'); → 分割代入 `},
{target:`module.exports`, content:`CommonJS modulesのキーワード。他のファイルに公開したい変数や関数を指定する。<br>複数の関数や変数をエクスポートしたい場合、オブジェクトを使ってまとめてエクスポートできる。exportsと併用できない。<br>calc.js<br>const add = (a, b) => a + b;<br>const subtract = (a, b) => a - b;<br>***.*** = {<br>&emsp;add: add,<br>&emsp;subtract: subtract<br>};<br>index.js<br>const calc = require('./calc');`},
{target:`ECMAScript modules`, content:`モジュールの分割方法。<br>JavaScriptの標準として策定されたモジュールの方式。スコープの管理や依存関係の解決がより効率的におこなえる。拡張子に.mjsを使用。<br>import fs from 'fs';`},
{target:`export`, content:`ECMAScript modulesのキーワード。変数や関数を外部に公開できる。<br>export defaultと共存できる。<br>calc.mjs<br>*** const num = 1;<br>*** const add = (a, b) => a + b;<br>index.mjs<br>import { num, add } from './calc.mjs';<br>console.log(num); → 1<br>let res = add(3, 1); → 4 `},
{target:`import`, content:`ECMAScript modulesのキーワード。モジュールを読み込む。<br>拡張子まで指定が必要。すべてのモジュールを読み込む場合は、asキーワードでモジュールに名前を付与した新しいオブジェクトとして読み込み可能。<br>calc.mjs<br>export const num = 1;<br>export const add = (a, b) => a + b;<br>index.mjs<br>*** { num, add } from './calc.mjs';<br>console.log(num); → 1<br>let res = add(3, 1); → 4<br>*** * as calc from './calc.mjs'; → すべてのモジュールを読み込む`},
{target:`as`, content:`ECMAScript modulesのキーワード。すべてのモジュールを読み込む。<br>拡張子まで指定が必要。<br>calc.mjs<br>export const num = 1;<br>export const add = (a, b) => a + b;<br>index.mjs<br>import * *** calc from './calc.mjs'; → すべてのモジュールを読み込む`},
{target:`export default`, content:`ECMAScript modulesのキーワード。他のファイルに公開したい変数や関数を指定する。<br>複数の関数や変数をエクスポートしたい場合、オブジェクトを使ってまとめてエクスポートできる。exportと共存が可能。<br>calc.mjs<br>*** *** function(){<br>&emsp;console.log('calc');<br>}<br>index.mjs<br>import defaultCalc from './calc.mjs';<br>defaultCalc(); → calcと表示`},
{target:`動的読込み(Dynamic Imports)`, content:`ECMAScript modulesの機能で、import()式にモジュールのパスを指定すると、import()式を読みだしたタイミングで初めてモジュールの読み込みが可能になる。<br>import('./calc.mjs');<br>&emsp;.then((module) => {<br>&emsp;&emsp;console.log(module.add(1, 2));<br>&emsp;});<br>document.querySelector('.addbutton').addEventListener('click', () => {<br>&emsp;import('./calc.mjs')<br>&emsp;&emsp;.then((module) => {<br>&emsp;&emsp;&emsp;const result = module.add(1, 2);<br>&emsp;&emsp;&emsp;document.querySelector('.result').innerText = result;<br>&emsp;&emsp;});<br>});`},
{target:`package.json`, content:`Node.jsプロジェクトの設定ファイル。プロジェクトに関する基本情報や依存関係、スクリプトなどを記述。<br>プロジェクトを管理しやすくし、他の開発者がプロジェクトを簡単に理解・利用できるようにする。<br>***.***<br>{<br>&emsp;'type': 'module'<br>}<br>{<br>&emsp;'name': 'my-project', → プロジェクトの名前<br>&emsp;'version': '1.0.0', → プロジェクトのバージョン<br>&emsp;'description': 'これはサンプルのプロジェクトです', → プロジェクトの説明<br>&emsp;'main': 'index.js', → エントリーポイントとなるファイル<br>&emsp;'scripts': { → コマンドのスクリプト<br>&emsp;&emsp;'start': 'node index.js',<br>&emsp;&emsp;'test': 'echo \'No tests specified\' && exit 1'<br>&emsp;},<br>&emsp;'author': '名前', → プロジェクトの作者<br>&emsp;'license': 'ISC', → プロジェクトのライセンス<br>&emsp;'dependencies': { → プロジェクトが依存しているパッケージ<br>&emsp;&emsp;'express': '^4.17.1'<br>&emsp;}<br>}`},
{target:`dependencies`, content:`package.jsonのプロパティ。アプリケーションを構成するモジュールを記録。<br>$ cat package.json<br>{<br>&emsp;…<br>&emsp;'***': {<br>&emsp;&emsp;'marked': '^4.2.4',<br>&emsp;&emsp;'yargs': '^17.6.2'<br>&emsp;},<br>&emsp;'devDependencies': {<br>&emsp;&emsp;'eslint': '^8.29.0'<br>&emsp;}<br>&emsp;…<br>}`},
{target:`devDependencies`, content:`package.jsonのプロパティ。開発時に必要なモジュールを記録。<br>$ cat package.json<br>{<br>&emsp;…<br>&emsp;'dependencies': {<br>&emsp;&emsp;'marked': '^4.2.4',<br>&emsp;&emsp;'yargs': '^17.6.2'<br>&emsp;},<br>&emsp;'***': {<br>&emsp;&emsp;'eslint': '^8.29.0'<br>&emsp;}<br>&emsp;…<br>}`},
{target:`package-lock.json`, content:`node_modulesディレクトリを復元するために必要なファイル。<br>npmが依存パッケージをインストールする際に生成される。`},
{target:`デュアルパッケージ`, content:`同じパッケージが異なる環境の両方で利用できるように設計されたもの。<br>パッケージを1つだけ用意すれば、両方の環境で再利用できる。<br>package.json<br>{<br>&emsp;'exports': {<br>&emsp;&emsp;'import': './index.mjs',<br>&emsp;&emsp;'require': './index.cjs'<br>&emsp;}<br>}`},
{target:`npm(node package manager)`, content:`Node.jsのパッケージマネージャー。コードをホスティングするレジストリとそれを操作するCLIからなる。<br>モジュールを利用・管理するためにはpackage.jsonが必要（例：private: trueとなるようなjsonファイルをディレクトリのルートに作成し、undiciをインストール）。<br>$ mkdir test_npm<br>$ cd test_npm<br>$ echo '{ 'private': true }' >> package.json → package.jsonの作成<br>$ cat package.json → package.jsonの内容表示<br>$ *** install undici --save → undiciのインストール<br>package.jsonの自動更新<br>{<br>&emsp;'private': true,<br>&emsp;'dependencies': {<br>&emsp;&emsp;'undici': '^5.14.0'<br>&emsp;}<br>}`},
{target:`ホスティング`, content:`通信事業者やインターネットサービスプロバイダが提供するサーバーのレンタルサービス。`},
{target:`レジストリ`, content:`Windowsでシステム（OS）やアプリケーションソフトの設定データなどを一元管理するデータベース。<br>ストレージ内のシステムドライブに保管されている。各項目はキー（key、項目名）と値（value）を一対一に対応付けたセットとして記録されている。値にはいくつかのデータ型が用意されており、文字列を格納できる文字列値や、任意のバイト列を格納できるバイナリ値、32ビットのビット列を格納できるDWORD値などが利用できる。`},
{target:`CLI(Command line interface)`, content:`コマンドラインインターフェースを通じて操作するツール。<br>ユーザーがコマンドを入力して操作を実行。開発者がスクリプトを実行したり、システム管理者がタスクを自動化したりする際に利用。<br>&lt;特徴&gt;<br>・コマンド入力：キーボードからコマンドを入力して操作<br>・スクリプト実行：簡単なコマンドから複雑なスクリプトまで実行可能<br>・自動化：繰り返しのタスクを自動化できる`},
{target:`npm install`, content:`npmのインストールコマンドを入力することで、package.jsonを参照し、アプリケーションが必要としているモジュールを一括で取得可能。<br>$ *** *** undici --save → undiciのインストール`},
{target:`npm private`, content:`package.jsonのプロパティ。trueを設定することで、そのパッケージがプライベートであり、パブリックなリポジトリに公開されないようにすることができる。<br>$ echo '{ '***': true }' >> package.json → package.jsonの作成`},
{target:`依存ツリー`, content:`ソフトウェアプロジェクトの依存関係を木構造で表したもの。<br>プロジェクトが直接依存しているパッケージやライブラリ（一次依存）だけでなく、それらのパッケージがさらに依存しているパッケージ（二次依存）なども含めて視覚的に示す。`},
{target:`npm scripts`, content:`package.jsonのプロパティ。プロジェクト内で共通して利用されるタスクなどをまとめる。<br>タスクは、npm run xxxのようにnpm経由で呼び出すことが可能。また、preをつけたスクリプトはタスク直前に、postをつけたスクリプトはタスク直後に自動的に実行される。preinstallやpostinstallでモジュールのインストール前後に初期化処理を行うなど、プロジェクト内で共通の処理がある場合、ここに記述しておくと便利。<br>package.json<br>{<br>&emsp;'private': true,<br>&emsp;'***': {<br>&emsp;&emsp;'prebuild': 'echo 'pre build'',<br>&emsp;&emsp;'build': 'echo 'build'',<br>&emsp;&emsp;'postbuild': 'echo 'post build'',<br>&emsp;}<br>}`},
{target:`セマンティックバージョニング(Semantic Versioning, semver)`, content:`ソフトウェアのバージョン番号に意味を持たせる規則。<br>バージョン番号を MAJOR.MINOR.PATCH の形式で表現し、それぞれに以下の意味を持たせる。<br>MAJOR：後方互換性が壊れる変更<br>MINOR：後方互換性のある機能追加<br>PATCH：後方互換性のあるバグ修正`},
{target:`バージョニング`, content:`ソフトウェアやドキュメントの異なるバージョンを識別するための方法。`},
{target:`undici`, content:`高性能なHTTPクライアントライブラリ。<br>イタリア語で'11'の意味（例：undiciを使用してYahooのウェブサイトからデータを取得するための非同期処理）。<br>$ npm install *** → インストール<br>const { request } = require('***');<br>request('https://www.yahoo.co.jp')<br>&emsp;.then((res) => {<br>&emsp;&emsp;return res.body.text()<br>&emsp;})<br>&emsp;.then((body) => {<br>&emsp;&emsp;console.log(body);<br>&emsp;})<br>&emsp;.catch((error) => {<br>&emsp;&emsp;console.error('Request failed:', error);<br>&emsp;});`},
{target:`HTTPクライアントライブラリ`, content:`プログラムからHTTPリクエストを送信し、HTTPレスポンスを受け取るための機能を提供するライブラリ。<br>APIとの通信やウェブサービスの利用が簡単に行えるようにする。<br>&lt;主な特徴&gt;<br>・リクエストの送信：GET、POST、PUT、DELETEなど、さまざまなHTTPメソッドを使ってリクエストを送信<br>・レスポンスの処理：サーバーからのレスポンスを受け取り、そのデータを扱うための機能を提供。通常、JSONやXMLなどの形式でデータを受け取る<br>・エラーハンドリング：通信エラーやHTTPステータスコードに基づくエラーハンドリングの機能がある<br>・非同期通信：多くのHTTPクライアントライブラリは、非同期通信をサポートしており、Promiseやasync/awaitを使って非同期にデータを処理できる<br>・設定とカスタマイズ：リクエストヘッダーの設定やタイムアウトの指定、認証情報の追加など、細かい設定が可能`},
{target:`undici request`, content:`undiciモジュールの関数。HTTPリクエストを送信し、レスポンスを処理できる（例：undiciを使用してYahooのウェブサイトからデータを取得するための非同期処理）。<br>const { *** } = require('undici');<br>***('https://www.yahoo.co.jp')<br>&emsp;.then((res) => {<br>&emsp;&emsp;return res.body.text()<br>&emsp;})<br>&emsp;.then((body) => {<br>&emsp;&emsp;console.log(body);<br>&emsp;})<br>&emsp;.catch((error) => {<br>&emsp;&emsp;console.error('Request failed:', error);<br>&emsp;});`},
{target:`イベントハンドリング`, content:`JavaScriptでイベント（ユーザーのアクションやシステムの状態変化など）が発生したときに、それに対する処理を記述する方法。`},
{target:`Callback`, content:`非同期処理を扱うための一般的な手法。関数を引数として渡し、処理が完了したときにその関数を呼び出す方法。<br>ネストが深くなりがち、包括的なエラーハンドリングが行えない弱点がある。第１引数がエラーオブジェクトのため、エラーハンドリングは必ず第１引数のnullチェックが必要。try-cathでエラーを補足できないため、処理をネストしていく場合は、必ずそれぞれのネストでエラーのnullチェックが必要。この処理をPromiseオブジェクトでラップすることで、Promise化が可能。<br>const { readFile } = require('fs');<br>readFile(__filename, (err, data) => {<br>&emsp;if (err) {<br>&emsp;&emsp;console.error(err);<br>&emsp;&emsp;return;<br>&emsp;}<br>&emsp;console.log(data);<br>});`},
{target:`Callback Hell`, content:`非同期処理を扱う際に、コールバック関数を多重にネストしてしまうことで発生する問題。<br>可読性が低下し、デバッグやメンテナンスが難しくなる。Promise、Async/Awaitなどを利用することで、コードをより読みやすく、メンテナンスしやすくする。`},
{target:`Promise`, content:`非同期処理を扱うオブジェクトで、処理の成功・失敗を返す。<br>resolve（成功）とreject（失敗）時に呼び出す関数を引数にもつ関数をコンストラクタとして生成。成功した場合はthenメソッドの成功時のハンドラーを呼び出し、失敗した場合はcatchメソッドのハンドラーが呼び出される。<br>thenメソッド: 成功した場合の処理を定義。成功した結果を受け取り、処理を行う<br>catchメソッド:失敗した場合の処理を定義。エラーを受け取り、エラーハンドリングを行う<br>thenやcatchをつなぐこと（チェイン）が可能で、ネストが深くなることを防ぎ、包括的なエラーハンドリングが可能。<br>const fetchData = new ***((resolve, reject) => {<br>&emsp;setTimeout(() => {<br>&emsp;&emsp;const data = 'This is some data';<br>&emsp;&emsp;resolve(data); → thenメソッドの引数<br>&emsp;}, 1000);<br>});<br>fetchData<br>&emsp;.then(data => data + '!!'); → 'This is some data!!'が次のthenメソッドの引数に受け継がれる<br>&emsp;.then(data2 => {<br>&emsp;&emsp;console.log('Data received:', data2); → 'Data received: This is some data!!'を表示<br>&emsp;})<br>&emsp;.catch(error => {<br>&emsp;&emsp;console.error('Error occurred:', error);<br>&emsp;});`},
{target:`ハンドラー`, content:`イベントや要求などを処理するための関数やメソッド（例：ハンドラーを作成し、呼び出す）。<br>handlers/user.js<br>const redis = require('../lib/redis');<br>const getUser = async (req) => {<br>&emsp;const key = 'users:' + req.params.id;<br>&emsp;const val = await redis.getClient().get(key);<br>&emsp;const user = JSON.parse(val);<br>&emsp;return user;<br>};<br>exports.getuser = getUser; → ハンドラーのエクスポート<br><br>server.js<br>const usersHandler = require('./handlers/user'); → ハンドラーの呼び出し<br>app.get('user/:id', async (req, res) => {<br>&emsp;try {<br>&emsp;&emsp;const user = await usersHandler.getUser(req); → ハンドラーの利用<br>&emsp;&emsp;res.status(200).json(user)<br>&emsp;} catch (err) {<br>&emsp;&emsp;console.error(err);<br>&emsp;&emsp;res.status(500).send('internal error');<br>&emsp;}<br>});`},
{target:`Promise then`, content:`JavaScriptのPromiseオブジェクトで非同期処理の結果を処理するために使うメソッド。<br>非同期処理の結果を処理し、その結果を次の非同期処理の引数として渡すことで、非同期処理をチェーンすることができる。これにより、非同期処理が順番に実行され、各処理の結果が次の処理に渡されることが保証される。`},
{target:`Promise catch`, content:`Promiseチェーン内で発生したエラーをキャッチして処理する。<br>具体的には、then()メソッドのチェーンの最後に配置され、前のPromiseで発生したエラーを受け取る。`},
{target:`Promiseのインターフェース`, content:`非同期操作の結果を表現するためのAPI。fsなどの標準モジュールは最初からPromiseのインターフェースが実装されている。<br>Promiseは次の3つの状態を持つ。<br>Pending（保留中）: 非同期操作がまだ完了していない状態<br>Fulfilled（達成済み）: 非同期操作が成功した状態<br>Rejected（拒否された）: 非同期操作が失敗した状態<br>then()、catch()、finally()などのメソッドを持ち、これらを使用して非同期操作の結果を処理する。<br>const fs = require('fs').promises;<br>fs.readFile('example.txt', 'utf8')<br>&emsp;.then(data => {<br>&emsp;&emsp;console.log('ファイルの内容:', data);<br>&emsp;})<br>&emsp;.catch(error => {<br>&emsp;&emsp;console.error('ファイルの読み込みエラー:', error);<br>&emsp;});<br><br>const { readFile, writeFile, chmod } = require('fs/promises');<br>const backupFile = __filename + '-' +Date.now();<br>readFile(__filename)<br>&emsp;.then((data) => {<br>&emsp;&emsp;return writeFile(backupFile, data);<br>&emsp;})<br>&emsp;.then(() => {<br>&emsp;&emsp;return chmod(backupFile, 0o400);<br>&emsp;})<br>&emsp;.catch((err) => {<br>&emsp;&emsp;console.error(err);<br>&emsp;});`},
{target:`コンストラクタ`, content:`オブジェクト指向プログラミングでクラスをインスタンス化する際に呼び出される特別なメソッド。`},
{target:`async/await`, content:`非同期処理を扱うためのキーワードで、より直感的で同期的なコードを書くことができる。<br>Promiseを利用した非同期処理を同期的な見た目で記述でき、可能な限り推奨。asyncをつけた関数を宣言すると、その中にawaitを記述できる。awaitは続く式から返されたPromiseの結果が判明するまで、その部分の実行を中止する。そのため非同期処理をasync関数内では同期処理のように、順次、簡潔に記述できる。<br>async関数: 非同期処理を含む関数を定義。関数の前に async キーワードを付ける<br>awaitキーワード: 非同期処理の実行を待つ。await キーワードを使うことで、非同期処理が完了するまで次の行の実行を待機<br>try/catchブロック: try ブロックで非同期処理を試行し、catch ブロックでエラーをキャッチしエラーハンドリングを行う<br>Promiseとasync/awaitは相互に呼び出しが可能。また、ループや条件分岐も同期コードのように直感的な記述が可能。また、async関数中ではtry-catchによるエラーハンドリングも可能。<br>const { readFile, writeFile, chmod } = require('fs/promises');<br>const main = async () => {<br>&emsp;const backupFile = __filename + '-' +Date.now();<br>&emsp;const data = await readFile(__filename)<br>&emsp;await writeFile(backupFile, data);<br>&emsp;await chmod(backupFile, 0o400);<br>&emsp;return 'done';<br>};<br>main()<br>&emsp;.then((data) => {<br>&emsp;&emsp;console.log(data);<br>&emsp;})<br>&emsp;.catch((err) => {<br>&emsp;&emsp;console.error(err);<br>&emsp;});`},
{target:`イベント駆動型非同期フロー制御`, content:`非同期操作が完了したときに特定の処理を実施。<br>コールバック関数やイベントリスナーを使用。「処理の開始」「処理の途中」「処理の終了」「エラー発生時」などさまざまなタイミングで処理を実施。データを逐次処理することでメモリを効率的に利用でき、イベントループを長時間停止させていしまう処理を分割したいといったケースで有効。`},
{target:`ストリーム処理`, content:`大きなデータを小さな塊に分割し、逐次的に処理する方法。<br>これにより、メモリの使用量を最適化し、高速で効率的なデータ処理が可能。`},
{target:`EventEmitter`, content:`イベント駆動型プログラミングを実現するためのクラスで、イベントの発行とリスナーの登録を管理。<br>onメソッドで特定のイベントにリスナーを登録し、emit メソッドでイベントを発行。ストリーム処理が必要な場合に推奨。代表的な処理には、HTTPリクエスト/レスポンス、TCP、標準入出力などがある。<br>const *** = require('events');<br>const myEmitter = new ***();<br>myEmitter.on('event', () => { → イベントに1つ目のリスナーを設定<br>&emsp;console.log('イベントが発生しました！');<br>myEmitter.on('event', (message) => { → イベントに2つ目のリスナーを設定<br>&emsp;console.log('イベントが発生しました！！' + message);<br>});<br>myEmitter.emit('event'); → イベントを発行`},
{target:`リスナー(Listener)`, content:`特定のイベントが発生したときに実行される関数。`},
{target:`イベント発行(イベント発火)`, content:`特定のイベントを発生させ、登録されているリスナーを実行する。`},
{target:`Stream`, content:`データをストリームとして扱うためのインターフェースで、非同期処理や大量のデータの処理に適している。<br>ファイルやHTTPリクエストなどの入出力ストリームを扱う。createReadStreamメソッドで読み取り可能なストリームを作成し、dataイベントでデータを取得。エラー処理はerrorイベントで行う。EventEmitterにデータをため込む内部バッファを組み込んだもので、内部バッファに一定量のデータがたまると、イベントが発生。目盛りの使用量を抑えやすい。イベントのつなぎあわせ、データの流量の調整、変換処理など連続するデータの流れを効率的に扱うことが可能で、ストリーム処理が必要な場合に推奨。<br>const fs = require('fs');<br>const readableStream = fs.createReadStream('example.txt', 'utf8');<br>readableStream.on('data', (chunk) => {<br>&emsp;console.log('読み込んだデータ:', chunk);<br>});<br>readableStream.on('error', (error) => {<br>&emsp;console.error('エラーが発生しました:', error);<br>});<br>const main = async () => {<br>&emsp;for (let i = 0; i < 10; i++) {<br>&emsp;&emsp;const flag = await asyncFunction();<br>&emsp;&emsp;if (flag) {<br>&emsp;&emsp;&emsp;break;<br>&emsp;&emsp;}<br>&emsp;}<br>};`},
{target:`Stream Writable(fs.createWriteStream)`, content:`Streamの種別。データの書き込みに利用。<br>writeとendメソッドの引数は、(chunk, [encoding], [callback])で、chunkは書き込むデータ、encodingは文字列データのエンコーディング（省略可）、callbackは書き込み完了したときに呼び出される関数（省略可）。endメソッドが呼び出されるとfinishイベントが発生。onメソッドの引数は(event, listener)で、eventは監視するイベント名、listenerはイベント発生時に実行される関数（例：fs.createWriteStream()、output.txtファイルに書き込む）。<br>const fs = require('fs');<br>const writeStream = fs.createWriteStream('output.txt');<br>writeStream.write('Hello, world!');<br>writeStream.write('This is a test.');<br>writeStream.end();<br>writeStream.on('finish', () => {<br>&emsp;console.log('ファイルへの書き込みが完了しました。');<br>});<br>writeStream.on('error', (err) => {<br>&emsp;console.error('エラーが発生しました:', err);<br>});<br>`},
{target:`Stream Readable(fs.createReadStream)`, content:`Streamの種別。データの読み取りに利用。<br>dataイベント：データ読取り開始<br>endイベント：データ読取り完了<br>errorイベント：エラー発生を受け取り<br>（例：fs.createReadStream()、input.txtファイルからデータを読み取る）<br>const fs = require('fs');<br>const readStream = fs.createReadStream('input.txt', 'utf8');<br>readStream.on('data', (chunk) => { → データ読取りごとにコールバック関数を実行<br>&emsp;console.log('読み取ったデータ:', chunk);<br>});<br>readStream.on('end', () => { → ファイル読取り完了ごとにコールバック関数を実行<br>&emsp;console.log('ファイルの読み取りが完了しました。');<br>});<br>readStream.on('error', (err) =>{ → エラー発生時にコールバック関数を実行<br>&emsp;console.error('エラーが発生しました:', err);<br>});`},
{target:`Stream Duplex`, content:`Streamの種別。書き込み/読み取りの両方に対応。<br>（例：net.Stocket、TCPソケットを作成し、読み取りと書き込みの両方を行う。ローカルホストの3000番ポートに接続するソケットを作成し、write()メソッドを使用してデータをサーバーに送信し、dataイベントを使用してサーバーからのデータを受信。また、endイベントとerrorイベントのハンドリング）。<br>const net = require('net');<br>const socket = net.connect({ port: 3000, host: 'localhost' });<br>socket.write('Hello, server!');<br>socket.on('data', (data) => {<br>&emsp;console.log('サーバーからのデータ:', data.toString());<br>});<br>socket.on('end', () => {<br>&emsp;console.log('接続が終了しました。');<br>});<br>socket.on('error', (err) => {<br>&emsp;console.error('エラーが発生しました:', err);<br>});`},
{target:`net.connect`, content:`netモジュールのメソッド。サーバーの接続に利用。<br>指定されたポートとホストに対して新しいソケットを作成し、そのソケットを返す。portは接続先のポート番号を指定、hostは接続先のホスト名またはIPアドレスを指定。<br>const net = require('net');<br>const socket = ***.***({ port: 3000, host: 'localhost' }); → ローカルホストのポート番号3000に接続`},
{target:`ポート番号`, content:`コンピューターネットワーク上の通信において、ノード（プログラムやサービス）を識別するための番号。<br>TCPやUDP通信において、送信元と受信先の両方が使用して通信を確立。ポート番号は0から65535までの範囲で指定。HTTPのポート番号は80、HTTPSのポート番号は443、FTPのポート番号は20（データ転送）と21（制御）。同じホスト上で複数のアプリケーションが同じポート番号を使用しようとすると、ポート番号の衝突が発生する。`},
{target:`ソケット`, content:`通信の一方の端点を表す。<br>通常、2つ揃うことで通信を確立、データの送受信が行わる。通信プロトコルによって定義され、通常はIPアドレスとポート番号の組み合わせで識別。`},
{target:`TCPソケット`, content:`Transmission Control Protocol (TCP) を使用して通信するためのソケット。<br>信頼性の高いデータ転送を提供し、データが順序通りに届くことを保証。接続指向のプロトコルであり、通常はクライアントとサーバー間の双方向通信を確立するために使用。`},
{target:`ローカルホスト`, content:`自分自身を指す特別なホスト名。<br>通常、IPv4アドレスでは「127.0.0.1」、IPv6アドレスでは「::1」にマッピング。これらのアドレスは、ローカルマシン上で動作しているプログラムやサービスにアクセスするために使用。同じコンピューター内で実行されているプログラムやサービスにアクセスすることができる。`},
{target:`Stream Transform`, content:`Streamの種別。Duplexを継承し、読み書きしたデータを変換する。<br>（例：zlib.createDeflate、データを圧縮するためのTransform Streamを作成。Deflateストリームを作成し、入力データを圧縮。dataイベントで圧縮されたデータを取得し、endイベントで圧縮が完了したことを検知。圧縮されたデータはBase64形式でログに出力）。<br>const zlib = require('zlib');<br>const input = 'Hello, world!';<br>const deflateStream = zlib.createDeflate();<br>deflateStream.write(input); → データを圧縮し、出力ストリームに書き込む<br>deflateStream.end();<br>let compressedData = Buffer.from(''); → 出力ストリームのデータを取得<br>deflateStream.on('data', (chunk) => {<br>&emsp;compressedData = Buffer.concat([compressedData, chunk]);<br>});<br>deflateStream.on('end', () => {<br>&emsp;console.log('圧縮されたデータ:', compressedData.toString('base64'));<br>});<br>deflateStream.on('error', (err) => { → 圧縮終了時の処理<br>&emsp;console.error('エラーが発生しました:', err);<br>});`},
{target:`libuv`, content:`バックエンドで使われるクロスプラットフォームの非同期I/Oライブラリ。<br>libuvは、非同期イベントループ、ファイルシステムアクセス、ネットワーク通信などの機能を提供し、Node.jsの非同期処理やイベント駆動型のプログラミングを可能にする。また、libuvはマルチスレッド環境での効率的なイベントループの実装をサポート。`},
{target:`クロスプラットフォーム`, content:`複数の異なるプラットフォーム（オペレーティングシステムやデバイス）で動作するソフトウェアやツール。<br>ソフトウェアは、1つのコードベースから複数のプラットフォームに対応し、異なる環境での動作を可能にする。これにより、開発者は効率的にソフトウェアを開発し、ユーザーは様々なプラットフォームで同じ機能を利用することができる。`},
{target:`fs`, content:`標準モジュール。ファイル作成/削除などの操作。<br>index.js<br>const fs = require('***');<br>fs.readFile(__filename, (err, data) => {<br>&emsp;console.log(data);<br>});`},
{target:`fs __filename`, content:`fsモジュール内の特殊な変数。自身のファイル名を参照。<br>index.js<br>const fs = require('fs');<br>fs.readFile(***, (err, data) => {<br>&emsp;console.log(data);<br>});`},
{target:`fs readFile`, content:`fsモジュールの関数。非同期的にファイルを読み取る。<br>指定されたファイルを非同期的に読み込み、コールバック関数を通じて読み込んだデータを返す。読み込むファイルのパスを指定し、オプションでエンコーディングやファイルの開き方を指定できる。コールバック関数では、第１引数でerrオブジェクトを受け取り（エラー発生しなかった時はnull）、第２引数でファイルから読み込まれたデータを受け取る。<br>const fs = require('fs');<br>fs.***('example.txt', 'utf8', (err, data) => { → example.txtファイルをutf8で読み込み、errとdataを引数で返す<br>&emsp;if (err) {<br>&emsp;&emsp;console.error('ファイルを読み込めませんでした:', err);<br>&emsp;&emsp;return;<br>&emsp;}<br>&emsp;console.log('ファイルの内容:', data);<br>});`},
{target:`fs writeFile`, content:`fsモジュールの関数。非同期的にファイルにデータを書き込むことができる。<br>const { readFile, ***, chmod } = require('fs/promises');<br>const backupFile = __filename + '-' +Date.now();<br>readFile(__filename)<br>&emsp;.then((data) => {<br>&emsp;&emsp;return ***(backupFile, data);<br>&emsp;})<br>&emsp;.then(() => {<br>&emsp;&emsp;return chmod(backupFile, 0o400);<br>&emsp;})<br>&emsp;.catch((err) => {<br>&emsp;&emsp;console.error(err);<br>&emsp;});`},
{target:`fs chmod`, content:`fsモジュールの関数。ファイルやディレクトリのパーミッション（アクセス権）を変更できる。<br>0oで以降の3つの数字でアクセス権を設定（所有者、グループ、その他ユーザー）。読取り許可 +4、書き込み許可 +2、実行許可 +1。<br>例<br>0o400：所有者のみ読取り権限を持つ。<br>0o755：所有者に全権限あり、グループとその他ユーザーは読取り、実行の権限を付与。<br>0o751：所有者に全権限あり、グループが読取りと実行の権限、その他ユーザーは実行のみ権限を持つ。<br>const { readFile, writeFile, *** } = require('fs/promises');<br>const backupFile = __filename + '-' +Date.now();<br>readFile(__filename)<br>&emsp;.then((data) => {<br>&emsp;&emsp;return writeFile(backupFile, data);<br>&emsp;})<br>&emsp;.then(() => {<br>&emsp;&emsp;return ***(backupFile, 0o400);<br>&emsp;})<br>&emsp;.catch((err) => {<br>&emsp;&emsp;console.error(err);<br>&emsp;});`},
{target:`AsyncIterator`, content:`非同期操作を逐次的に処理するためのインターフェース。<br>複数回登場するイベント（dataなど）の非同期操作をfor...await...ofループで扱うことが可能。async/awaitとストリーム処理の相性を劇的に向上（例：readFileLines関数がファイルを読み込み、各行を非同期に生成。for await...ofループを使って、各行を逐次処理）。<br>const fs = require('fs').promises;<br>async function* readFileLines(filePath) {<br>&emsp;const data = await fs.readFile(filePath, 'utf8');<br>&emsp;const lines = data.split('\n');<br>&emsp;for (const line of lines) {<br>&emsp;&emsp;yield line;<br>&emsp;}<br>}<br>(async () => {<br>&emsp;for await (const line of readFileLines('example.txt')) {<br>&emsp;&emsp;console.log(line);<br>&emsp;}<br>})();<br><br>function* generator() {<br>&emsp;yield 'Hello';<br>&emsp;yield 'Generator';<br>}<br>const gen = generator();<br>console.log(gen.next().value); → Hello<br>console.log(gen.next().value); → Generator`},
{target:`ジェネレータ関数`, content:`yieldキーワードを使って複数の値を逐次的に返す。<br>さらに、asyncと組み合わせることで、非同期ジェネレータ関数を定義し、非同期に複数の値を返すことができる。本来非同期のStreamを順次処理できるため（async/awaitにStreamを持ち込む）、try-catchなどのエラーハンドリングが可能。<br>yield：ジェネレータ関数や非同期ジェネレータ関数で、複数の値を逐次的に返すために使用<br>await：非同期操作を待機するために使用し、非同期ジェネレータ関数の中で使用<br>for await...ofループ：非同期イテレータを反復処理するために使用し、非同期ジェネレータ関数の値を逐次的に処理<br>async function* asyncGenerator() {<br>&emsp;yield await Promise.resolve('Hello');<br>&emsp;yield await Promise.resolve('Async');<br>&emsp;yield await Promise.resolve('Generator');<br>}<br>(async () => {<br>&emsp;for await (const value of asyncGenerator()) {<br>&emsp;&emsp;console.log(value);<br>&emsp;}<br>})();<br>`},
{target:`エラーハンドリング`, content:`プログラム中で発生する可能性のあるエラーを適切に処理するための方法。<br>プログラムのクラッシュを防ぎ、エラーの情報を提供して対処できる。<br>同期処理：try-catchで囲う、async/awaitでラップ<br>Callback：if (err)<br>EventEmitter(Stream)：emitter.on('error')<br>async/await：try-catch, .catch()<br>AsyncIterator：try-catch, .catch()`},
{target:`Top-Level Await`, content:`ECMAScript modulesのみ。モジュールのトップレベルスコープでawaitを記述でき、非同期操作を簡単に行える。<br>CLIツールなどで効果を発揮。<br>import { readFile } from 'fs/promises';<br>try {<br>&emsp;const data = await readFile('example.txt', 'utf8');<br>&emsp;console.log(data);<br>} catch (error) {<br>&emsp;console.error('ファイルの読み込みエラー:', error);<br>}`},
{target:`processオブジェクト`, content:`グローバルオブジェクトで、現在のNode.jsプロセスに関する情報や制御を提供。<br>&lt;主なプロパティとメソッド&gt;<br>・process.argv：コマンドライン引数の配列<br>・process.env：環境変数のオブジェクト<br>・process.cwd()：現在の作業ディレクトリを取得<br>・process.exit([code])：プロセスを終了。終了コードを指定可能<br>・process.stdin：標準入力のストリーム<br>・process.stdout：標準出力のストリーム<br>・process.stderr：標準エラー出力のストリーム<br><br>argv.js<br>console.log(process.argv);<br><br>$ node argv.js one two=three --four → argv.jsに'one'、'two=three'、'--four'の引数を渡す<br>[ → process.argvの内容を表示<br>&emsp;'/usr/local/bin/node',<br>&emsp;'/home/xxx/dev/cli_test/argv.js',<br>&emsp;'one',<br>&emsp;'two=three',<br>&emsp;'--four'<br>]`},
{target:`npm yargs`, content:`CLIツールを簡単に作成するためのモジュール。<br>コマンドライン引数の解析やコマンドの定義をサポートする。<br>&lt;主な機能&gt;<br>・引数解析：コマンドライン引数を簡単に解析<br>・コマンド定義：複数のコマンドを定義し、個別に処理<br>・オプションとフラグ：短縮形と長い形のオプションをサポート<br>・ヘルプとバージョン：自動的にヘルプとバージョン情報を生成<br>.option('optionname'で指定すると、argvオブジェクトに説明やデフォルト値などを追加できる。,br>$ npm install ***<br>index.js<br>const path = require('path');<br>const fs = require('fs');<br>const yargs = require('***/***');<br>const { hideBin } = require('***/helpers'); → コマンドライン引数をパースするためのヘルパー関数<br>const { argv } = yargs(hideBin(process.argv)); → 3つ目以降の引数を取得<br>&emsp;.option('name', { → オプションの説明を追加<br>&emsp;&emsp;describe: 'CLI名を表示'<br>&emsp;})<br>&emsp;.option('file', {<br>&emsp;&emsp;describe: 'Markdownファイルのパス'<br>&emsp;})<br>console.og(argv) → 引数を表示<br>続きはyargs（2）に記載`},
{target:`yargs(2)`, content:`CLIツールを簡単に作成するためのモジュール（yargsの続き）。<br>const packageStr = fs.readFileSync(path.resolve(__dirname, 'package.json'), encoding: 'utf-8' });<br>const package = JSON.parse(packageStr); →  読み込んだファイルの内容をJSONオブジェクトに変換<br>if (argv.file) { → argvオプションのfileがあれば<br>&emsp;console.log(argv.file);<br>} else { if (argv.name) {<br>&emsp;console.log(package.name);<br>} else {<br>&emsp;console.log('オプションがありません');<br>}<br><br>$ node index.js --name → nameオプション取得確認<br>{ _:[], name: true, '$0': 'index.js'}<br>$ node index.js --version → package.jsonのバージョンを確認<br>1.0.0<br>`},
{target:`Markdownファイル`, content:`軽量マークアップ言語で書かれたテキストファイルで、.md拡張子を持ち、シンプルな書式で文書を記述し、HTMLに変換できる。<br>&lt;特徴&gt;<br>・簡単な書式：プレーンテキストに記述、直感的な書式設定<br>・可読性：生のテキストが読みやすく、編集が容易<br>・変換可能：HTMLやPDFなどに簡単に変換<br>article.md → 作成したファイルは作業ディレクトリに配置<br># タイトル<br>hello!<br>**テスト**<br>'''javascript<br>const foo = 'bar';<br>'''<br>index.jsはMarkdownファイル（2）に記載`},
{target:`Markdownファイル(2)`, content:`軽量マークアップ言語で書かれたテキストファイルでHTMLに変換できる（Markdownファイルの続き）。<br>index.js<br>const path = require('path');<br>const fs = require('fs');<br>const yargs = require('yargs/yargs');<br>const { hideBin } = require('yargs/helpers');<br>const { argv } = yargs(hideBin(process.argv));<br>&emsp;.option('name', {<br>&emsp;&emsp;describe: 'CLI名を表示'<br>&emsp;})<br>&emsp;.option('file', {<br>&emsp;&emsp;describe: 'Markdownファイルのパス'<br>&emsp;})<br>if (argv.name)<br>&emsp;const packageStr = fs.readFileSync(path.resolve(__dirname, 'package.json'), encoding: 'utf-8' });<br>&emsp;const package = JSON.parse(packageStr);<br>&emsp;console.log(package.name);<br>&emsp;process.exit(0); → nameオプションがある場合、他のオプションを使わず正常終了させる<br>}<br>const markdownStr = fs.readFileSync(path.resolve(__dirname, argv.file), {encoding: 'utf-8 });<br>console.log(markdownStr);<br><br>$ node index.js --file=./article.md → markdownファイルの確認`},
{target:`ファイル分割`, content:`ファイルを分割し、コードの見通しをよくする。一部コードを関数化し、libディレクトリに切り出す。<br>より保守性の高いコードにするためMarkdownファイルを読み込む関数では絶対パスを引数で受ける形にする。<br>directory/<br>&emsp;lib/<br>&emsp;&emsp;name.js → name関数<br>&emsp;&emsp;file.js → file関数<br>&emsp;article.md → markdownファイル<br>&emsp;index.js<br>&emsp;package.json<br>&emsp;package-lock.json<br>lib/name.js → name関数<br>const path = require('path');<br>const fs = require('fs');<br>const packgeStr = fs.readFileSync(path.resolve(__dirname, '../package.json'), { encoding: 'utf-8' });<br>const package = JSON.parse(packageStr);<br>exports.getPackageName = () => {<br>&emsp;return package.name;<br>};<br>lib/file.js → file関数<br>const fs = require('fs');<br>exports.readMarkdownFileSync = (path) => {<br>&emsp;const markdownStr = fs.readFileSync(path, { encoding: 'utf-8' });<br>&emsp;return markdownStr;<br>};<br>index.jsはファイル分割（2）に記載`},
{target:`ファイル分割(2)`, content:`ファイルを分割し、コードの見通しをよくする（ファイル分割の続き）。<br>index.js<br>const path = require('path');<br>const yargs = require('yargs/yargs');<br>const { hideBin } = require('yargs/helpers');<br>const { getPakageName } = require('./lib/name');<br>const { readMarkdownFileSync } = require('./lib/file');<br>const { argv } = yargs(hideBin(process.argv));<br>&emsp;.option('name', {<br>&emsp;&emsp;describe: 'CLI名を表示'<br>&emsp;})<br>&emsp;.option('file', {<br>&emsp;&emsp;describe: 'Markdownファイルのパス'<br>&emsp;})<br>if (argv.name)<br>&emsp;const name = getPackageName();<br>&emsp;console.log(name);<br>&emsp;process.exit(0);<br>}<br>const markdownStr = readMarkdownFileSync(path.resolve(__dirname, argv.file));<br>console.log(markdownStr);<br><br>$ node index.js --file=./article.md → markdownファイルの確認`},
{target:`process.cwd()`, content:`processオブジェクトのメソッドで、現在の作業ディレクトリを返す。<br>Webサービス等での利用には、実行するコンテキストで変わる変数の利用は、サーバーへの不正アクセスや情報漏洩のリスクがあり注意が必要。<br>const currentDir = ***.***(); → 現在の作業ディレクトリ`},
{target:`marked`, content:`npmモジュール。高速なMarkdownパーサーおよびコンパイラ。<br>MarkdownファイルをHTMLに変換する。<br>$ npm install *** → インストール<br>const marked = require('***');<br>const markdownText = '# Hello, Markdown!\nThis is a paragraph.';<br>const htmlText = marked(markdownText); → MarkdownをHTMLに変換<br>console.log(htmlText);<br><br>lib/file.js<br>const fs = require('fs');<br>exports.readMarkdownFileSync = (path) => {<br>&emsp;const markdownStr = fs.readFileSync(path, { encoding: 'utf-8' });<br>&emsp;return markdownStr;<br>};<br>exports.writeHtmlFilesync = (path, html) => {<br>&emsp;fs.writeFileSync(path, html, { encoding: 'utf-8' });<br>};<br>index.jsはmarked（2）に記載`},
{target:`marked(2)`, content:`MarkdownファイルをHTMLに変換する。<br>index.js<br>const { marked}  = require('marked'); → markedを追加<br>const yargs = require('yargs/yargs');<br>const { hideBin } = require('yargs/helpers');<br>const { getPakageName } = require('./lib/name');<br>const { readMarkdownFileSync, writeHtmlFileSync } = require('./lib/file');<br>const { argv } = yargs(hideBin(process.argv));<br>&emsp;.option('name', {<br>&emsp;&emsp;describe: 'CLI名を表示'<br>&emsp;})<br>&emsp;.option('file', {<br>&emsp;&emsp;describe: 'Markdownファイルのパス'<br>&emsp;})<br>&emsp;.option('out', { → outオプションを追加<br>&emsp;&emsp;describe: 'html file',<br>&emsp;&emsp;default: 'article.html'<br>&emsp;]);<br>if (argv.name)<br>&emsp;const name = getPackageName();<br>&emsp;console.log(name);<br>&emsp;process.exit(0);<br>}<br>const markdownStr = readMarkdownFileSync(path.resolve(__dirname, argv.file));<br>console.log(markdownStr);<br>writeHtmlFileSync(path.resolve(__dirname, argv.out), html); → htmlをファイルに書き出し<br>$ node index.js --file=./article.md → markdownファイルの確認<br>$ cat article.html`},
{target:`prismjs`, content:`npmモジュール。軽量で拡張可能なシンタックスハイライター（構文強調表示ライブラリ）。<br>HTML内のコードスニペットに色やスタイルを適用して、読みやすくするために使用。多くのプログラミング言語をサポートしており、カスタマイズも容易。<br>$ npm install *** → インストール<br>const Prism = require('***');<br>const loadLanguages = require('***/components/');<br>loadLanguages(['javascript', 'python']); → 必要な言語をロード<br>const code = '<br>def hello():<br>&emsp;print('Hello, world!')<br>';<br>const html = Prism.highlight(code, Prism.languages.python, 'python');<br>console.log(html);`},
{target:`コードスニペット`, content:`プログラムの一部を抜き出した短いコードの断片。<br>再利用可能なコードの小さなブロックなど。`},
{target:`eslint`, content:`静的解析ツールで、コードの品質を向上させるために使用。<br>コーディングスタイルや構文エラーをチェックし、コードベースを一貫性のあるものに保つために役立つ。<br>$ npm install *** --save-dev → インストール<br>.eslintrc.js<br>module.exports = {<br>&emsp;env: {<br>&emsp;&emsp;commonjs: true,<br>&emsp;&emsp;es2021: true,<br>&emsp;&emsp;node: true<br>&emsp;},<br>&emsp;parserOptions: {<br>&emsp;&emsp;ecmaVersion: 12<br>&emsp;},<br>&emsp;rules: {<br>&emsp;&emsp;quotes: ['error', 'double'] → 例：ダブルクォートでないとエラーと表示<br>&emsp;}<br>&emsp;extend: '***:recommended' → おすすめ設定の読み込み<br>};<br>pachake.json<br>{<br>&emsp;'script': {<br>&emsp;&emsp;'lint': '*** *.js lib/**/*.js', → npmのscriptsにショートカットを登録<br>&emsp;&emsp;'test': 'echo \'Error: no test specified\' && exit 1'<br>&emsp;},<br>}<br>$ npm run lint → 登録した***を呼び出し`},
{target:`アサーション関数`, content:`プログラムの実行中に特定の条件が成り立つことを確認するための関数。<br>テストやデバッグの際に使用され、期待される結果と実際の結果が一致するかどうかをチェックす。条件が満たされない場合、アサーション関数はエラーをスローする。`},
{target:`assert`, content:`条件が満たされていることを確認するために使用されるアサーション関数のモジュール。<br>const assert = require('***');<br>assert.equal(1, '1', '数値と文字列の比較'); → OK<br>assert.strictEqual(1, '1', '数値と文字列の比較（strict）'); → NG<br>assert.deepStrictEqual(obj1, obj2, 'オブジェクトの比較'); `},
{target:`テストランナー`, content:`テストケースを実行し、その結果を集計してレポートを生成。<br>コードの変更が既存の機能を壊していないことを確認でき、品質の維持やバグの早期発見に役立つ。Jestやmochaなど。`},
{target:`jest`, content:`Reactアプリケーションのテストに適しているテストランナー。<br>テストの実行管理だけでなく、モックやアサーション関数なども提供。test関数やexpect関数はこのコマンドを実行すると自動的にグローバルに追加される。<br>$ npm install --save-dev *** → インストール<br>sample.test.js<br>test('sample test', () => {<br>&emsp;expect(1 + 2), toStrictEqual(3);<br>});<br>$ npm test → *.test.jsファイルのテストを実行`},
{target:`prettier`, content:`コードのスタイルを統一し、可読性を向上させるコードフォーマッター（コード整形ツール）。<br>JavaScript、TypeScript、HTML、CSS、Markdownなど、さまざまな言語をサポート。<br>$ npm install --save-dev *** → インストール<br>$ npx *** --write 'src/**/*.js' → srcディレクトリ内のすべてのJavaScriptファイルを整形`},
{target:`dayjs`, content:`軽量でモダンな日付と時間の操作モジュール。<br>$ npm install *** → インストール<br>const dayjs = require('***');<br>const str = dayjs(72021-01-23').format('YYYY/MM/DD');<br>console.log(str) → 2021/01/23`},
{target:`ネットワーク処理`, content:`ンピュータ間の通信を管理し、データの送受信を行うための処理。<br>データパケットの作成、送信、受信、エラーチェック、接続の確立と管理などが含まれる。アプリケーションがインターネットやローカルネットワークを介して通信する際に不可欠。主要なプロトコルとしては、TCP/IP、UDP、HTTP、FTPなど。`},
{target:`データパケット`, content:`ネットワーク上でデータを送受信する際に、データを小さな単位に分割したもの。`},
{target:`APIサーバー`, content:`アプリケーションプログラムインターフェース（API）を通じて他のソフトウェアやサービスと通信するためのサーバー。<br>クライアント（例えば、ウェブブラウザやモバイルアプリ）からのリクエストを受け取り、データベースや他のサービスと連携して必要なデータを取得し、その結果をクライアントに返す役割を果たす。ウェブサービスやマイクロサービスアーキテクチャにおいて重要なコンポーネント。`},
{target:`Express`, content:`ウェブアプリケーションやAPIを構築するためのシンプルで柔軟なフレームワーク。<br>ルーティング、ミドルウェア、テンプレートエンジンの統合など、ウェブアプリケーション開発に必要な基本的な機能を提供。迅速かつ効率的にサーバーサイドのアプリケーションを構築できる。<br>$ npm install *** → インストール<br>server.js<br>const *** = require('***');<br>const app = ***(); → サーバー用のインスタンスを作成<br>app.get('/', (req, res) => { → ルートを定義（ルーティング）<br>&emsp;res.status(200).send('hello world');<br>});<br>app.get('user/:id', (res, req) => {<br>&emsp;res.status(200).send(req.params.id);<br>});<br>app.listen(3000, () => { → ポート3000でサーバーを起動<br>&emsp;console.log('start listening');<br>});<br>$ node server.js → サーバー起動 → start listening<br>$ curl http://localhost:3000 → hello world<br>$ curl http://localhost:3000/user/foo → foo（:をつけてルート定義することで変数（req.prames.id → foo）として受け取り可能）`},
{target:`Express get`, content:`Expressのメソッド。特定のパスに対してクライアントからのデータ取得リクエストを処理するためのルートハンドラーを定義。<br>引数(path, callback)は、path：リクエストのパス（例：'/'）、callback：ルートが一致したときに実行される関数。callbackの引数(req, res)は、req：リスエストオブジェクト、res：レスポンスオブジェクト。<br>const express = require('express');<br>const app = express(); → サーバー用のインスタンスを作成<br>app.***('/', (req, res) => { → ルートを定義（ルーティング）<br>&emsp;res.status(200).send('hello world');<br>});<br>app.***('user/:id', (res, req) => {<br>&emsp;res.status(200).send(req.params.id);<br>});<br>app.listen(3000, () => { → ポート3000でサーバーを起動<br>&emsp;console.log('start listening');<br>});<br>$ node server.js → サーバー起動 → start listening<br>$ curl http://localhost:3000 → hello world<br>$ curl http://localhost:3000/user/foo → foo（:をつけてルート定義することで変数（req.prames.id → foo）として受け取り可能）`},
{target:`req(リクエストオブジェクト)`, content:`HTTPリクエストに関する情報。<br>&lt;主なプロパティ&gt;<br>・***.params：ルートパラメータ。URLの動的セグメントにマッチ<br>・***.query：クエリパラメータ。URLのクエリストリングに含まれるデータ<br>・***.body：リクエストボディ。POSTやPUTリクエストで送信されたデータ<br>・***.headers：リクエストヘッダ。リクエストに含まれるメタデータ<br>app.get('/user/:id', (***, res) => {<br>&emsp;const userId = ***.params.id; → ルートパラメータ<br>&emsp;const queryParam = ***.query.name; → クエリパラメータ<br>&emsp;res.send('User ID: ' + userId + ' Query Name: ' +queryParam);<br>});<br>app.listen(port, () => { → サーバーを起動<br>&emsp;console.log('Server running at http://localhost:' + port);<br>});<br>$ curl http://localhost:3000/user/123?name=John → User ID: 123, Query Name: Johnと表示`},
{target:`res(レスポンスオブジェクト)`, content:`クライアントに送信されるレスポンスに関する情報。<br>&lt;主なメソッド・プロパティ&gt;<br>・***.send()：レスポンスを送信。引数には文字列、JSONオブジェクト、またはバッファを指定<br>・***.json()：JSON形式のデータを送信<br>・***.status()：レスポンスのステータスコードを設定<br>・***.setHeader()：レスポンスヘッダーを設定<br>・***.redirect()：リダイレクト<br>・***.offset()：オフセットを取得<br>・***.render()：HTMLをレンダリングし、クライアントに送信。動的なHTMLコンテンツ生成に利用<br>app.get('/user/:id', (req, ***) => {<br>&emsp;const userId = req.params.id; → ルートパラメータ<br>&emsp;const queryParam = req.query.name; → クエリパラメータ<br>&emsp;***.send('User ID: ' + userId + ' Query Name: ' +queryParam);<br>});<br>app.listen(port, () => { → サーバーを起動<br>&emsp;console.log('Server running at http://localhost:' + port);<br>});<br>$ curl http://localhost:3000/user/123?name=John → User ID: 123, Query Name: Johnと表示`},
{target:`ステータスコード`, content:`HTTPプロトコルでクライアントとサーバーの間でやり取りされるリクエストおよびレスポンスの状態を示す3桁の数値。<br>これは、クライアントがリクエストを正常に処理したか、エラーが発生したか、またはリダイレクトが行われたかなどの状態を示す。<br>代表的なステータスコード<br>200：OK、リクエストが成功し、レスポンスが正常に返された<br>201：Created、リクエストが成功し、新しいリソースが作成された<br>204：No Content、リクエストが成功し、レスポンスにはコンテンツが含まれていない<br>400：Bad Request、クライアントのリクエストが不正であるため、サーバーが理解できない<br>401：Unauthorized、認証が必要なリソースに対するリクエストが認証されていない<br>403：Forbidden、クライアントがリソースにアクセスする権限がない<br>404：Not Found、リクエストされたリソースが見つからない<br>500：Internal Server Error、サーバーで予期しないエラーが発生`},
{target:`オフセット`, content:`位置や距離を示す数値であり、通常は基準点からの相対的な位置を表す。<br>ページネーション：ウェブページやアプリケーションで、大量のデータを複数のページに分割して表示する場合、各ページが開始するデータの位置を示すために使用<br>データベースクエリ：データベースから取得される結果セットのうち、最初の行からの相対的な位置を示すために使用。クエリ結果の一部のみを取得するために、スキップする行数を指定<br>レイアウト：グラフィックデザインやレイアウト設計のコンテキストでは、要素の位置を調整するために使用。テキストや画像の配置を微調整する場合に使用`},
{target:`Express listen`, content:`Expressのメソッド。指定したポートでリクエストを待ち受け、サーバーを起動する。<br>HTTPリクエストを受け付け、適切なルートハンドラーにリクエストをルーティングすることが可能。<br>const express = require('express');<br>const app = express(); → サーバー用のインスタンスを作成<br>app.get('/', (req, res) => { → ルートを定義（ルーティング）<br>&emsp;res.status(200).send('hello world');<br>});<br>app.get('user/:id', (res, req) => {<br>&emsp;res.status(200).send(req.params.id);<br>});<br>app.***(3000, () => { → ポート3000でサーバーを起動<br>&emsp;console.log('start listening');<br>});<br>$ node server.js → サーバー起動 → start listening<br>$ curl http://localhost:3000 → hello world<br>$ curl http://localhost:3000/user/foo → foo（:をつけてルート定義することで変数（req.prames.id → foo）として受け取り可能）`},
{target:`Express set`, content:`Expressのメソッド。Expressアプリケーションの設定を行う。<br>設定はキーと値のペアで指定し、アプリケーション全体に影響を与えるさまざまな構成オプションを管理できる。<br>&lt;主な設定項目&gt;<br>・'view engine'：テンプレートエンジンの種類。例：ejs、pug<br>・'views'：テンプレートファイルが格納されているディレクトリのパスを指定<br>・'port'：サーバーがリッスンするポート番号を指定<br>・'trust proxy'：プロキシサーバーの信頼設定<br>・'jsonp callback name'：JSONPリクエストで使用されるコールバック関数の名前を設定<br>app.***(name, value) → name：設定項目、value：値<br>const express = require('express');<br>const app = express();<br>app.***('view engine', 'ejs') → ビューテンプレートのエンジンを指定<br>app.***('views', './views'); → ビューテンプレートの格納ディレクトリを設定<br>app.get('/views', (req, res) => {<br>&emsp;res.render(…) → ejsを描写<br>})<br>app.***('port', process.env.PORT || 3000); → ポート番号を設定<br>app.***('title', 'My Application'); → カスタム設定を追加`},
{target:`Express post`, content:`Expressのメソッド。ExpressアプリケーションでHTTP POSTリクエストに対するルートハンドラーを定義。<br>クライアントから送信されたデータをサーバー側で処理できる。<br>app.***(path, callback) → path：ルートパスの指定、callback：リクエスト一致後に実行される関数。引数に(req, res, next)を受け取る<br>const express = require('express');<br>const app = express();<br>app.use(express.urlencoded({ extended: true })); → POSTリクエストのボディを解析するためのミドルウェア<br>app.***('/submit', (req, res) => { → POSTリクエストのルートを定義<br>&emsp;const { name, email } = req.body; → フォームから送信されたデータを取得<br>&emsp;res.send('Name: ' + name + ', Email: ' + email); → レスポンスを送信<br>});<br>app.listen(3000, () => { → サーバーを起動<br>&emsp;console.log('Server is listening on port 3000');<br>});`},
{target:`Express urlencoded`, content:`Expressのミドルウェア。ExpressアプリケーションでPOSTリクエストの本文を解析。<br>URLエンコードされたデータ（通常はフォームデータ）を解析し、req.bodyオブジェクトにデコードされたデータを格納することができる。また、extendedオプションを使用することで、単純なキーとバリューのペアだけでなく、ネストされたオブジェクトを含む複雑なデータも解析することができる。<br>extended (boolean)：true → ネストされたオブジェクトを含む複雑なデータを解析可能<br>extended (boolean)：false → クエリストリングライブラリのquerystringが使用され、シンプルなキーとバリューのペアのみを解析`},
{target:`ルートハンドラー`, content:`Expressアプリケーションで特定のURLパスに対するリクエストを処理する関数。<br>app.get()、app.post()などのHTTPメソッドと組み合わせて使用され、特定のURLに対してリクエストが送信されたときに実行される処理を定義。クライアントからのリクエストに対してデータを処理し、適切なレスポンスを生成する役割を果たす。`},
{target:`ルーティング`, content:`WebアプリケーションにおけるHTTPリクエストの処理を制御するための手法のこと。<br>クライアントからのHTTPリクエストを、それに対応するハンドラー関数にマッピングするプロセス。URLやHTTPメソッド（GET、POST、PUT、DELETEなど）に基づいて、リクエストを処理するための適切なハンドラー関数やコントローラーを呼び出す。特定のURLパスに対してどのような処理を行うかを指定し、アプリケーションの構造化や保守性を向上させることができる。具体的には、特定のURLパスに対してどのような処理を行うかを定義し、その処理を実行するための関数を割り当てる。これにより、ウェブアプリケーションはリクエストを受け取り、適切なレスポンスを返すことが可能。`},
{target:`ミドルウェア`, content:`Expressアプリケーションにおいて、リクエストとレスポンスの間で動作する関数。<br>HTTPリクエストを処理する前や後に特定の処理を実行するために使用（例：ログ記録、認証、セッション管理、エラーハンドリングなど）。app.getやapp.use()メソッドを使用してアプリケーションに追加され、リクエストのパイプライン内で順番に実行される（順に並べることで連鎖的に呼び出しも可能）。これにより、リクエストとレスポンスの処理を柔軟かつ効率的にカスタマイズすることが可能になる。次のを呼び出す場合は第3引数に渡されるnextという関数を用いる（例：リクエストが発生するたびに、リクエストのHTTPメソッドとURLをコンソールにログとして出力）。<br>const express = require('express');<br>const app = express();<br>app.use((req, res, next) => { → リクエストログを出力するミドルウェアをアプリケーションに追加<br>&emsp;console.log('[' + new Date() + ']' + ' ' + req.method + ' ' + req.url);<br>&emsp;next(); → 次のミドルウェアまたはルートハンドラーに処理を委譲<br>});<br>app.get('/', (req, res) => { → ルートハンドラー<br>&emsp;res.send('Hello World!');<br>});<br>app.listen(3000, () => { → サーバーを起動<br>&emsp;console.log('Server is listening on port' + port);<br>});<br>$ curl http://localhost:3000/<br> → Server is listening on port 3000<br> → [Thu Mar 24 2022 13:42:22 GMT+0000 (Coordinated Universal Time)] GET /<br> → Hello World!`},
{target:`Express use`, content:`Expressのメソッド。Expressアプリケーションにミドルウェア関数を追加。<br>ミドルウェアは、リクエストとレスポンスの処理の間に実行される関数で、リクエストの解析、認証、ログ記録、エラーハンドリングなどのタスクを実行するために使用。<br>app.***([path,] callback [, callback ...])<br> → path：ミドルウェア関数を適用するルートパス。省略は全ルートに適用<br>&emsp;callback：ミドルウェア関数。引数に(req, res, next)を受け取る`},
{target:`包括的エラーハンドリング`, content:`Expressアプリケーションにおいて、特殊なミドルウェアとして、エラーが発生した際に、そのエラーを適切にキャッチして処理する仕組み。<br>4つの引数があることが条件で呼び出される。第１引数にエラー内容、第２引数にリクエスト、第3引数にレスポンス、第4引数にnextをとる。アプリケーション全体で一貫した方法でエラーを処理。app.getやapp.useの最後に呼ばれるように定義。<br>server.js<br>const express = require('express');<br>const app = express();<br>app.get('/', (req,res) => { → ルーティングとミドルウェア<br>&emsp;res.status(200).send('hello world!!');<br>});<br>app.use((err, req, res, next) => { → 包括的エラーハンドリング<br>&emsp;res.status(500).send('Internal Server Error');<br>});<app.listen(3000, () => {<br>&emsp;console.log('start listening');<br>});`},
{target:`Redis(Remote Dictionary Server)`, content:`オープンソースのインメモリデータ構造ストアであり、主にデータベース、キャッシュ、メッセージブローカーとして利用。<br>主にメモリ内でデータを保持し、非常に高速な読み書き操作を提供し、多様なデータ構造（文字列（Strings）、リスト（Lists）、セット（Sets）、ソート済みセット（Sorted Sets）、ハッシュ（Hashes）、ビットマップ（Bitmaps）、ハイパーログログ（HyperLogLog）、ストリーム（Streams）など）をサポート。<br>&lt;主な特徴&gt;<br>・高速性：メモリ内にデータを保持するため、非常に高速な読み書き操作が可能<br>・永続性：データをディスクに保存する機能があり、再起動後もデータを保持<br>・スケーラビリティ：分散型クラスター構成をサポートし、データを分散して管理可能<br>・多様な用途：キャッシュ、セッション管理、リアルタイム分析、ランキングシステム、メッセージキューなど、さまざまな用途に利用`},
{target:`ioredis`, content:`Node.js用のRedisクライアントモジュール。シンプルなAPIで、非同期I/Oを利用して効率的なパフォーマンスを提供。<br>クラスターサポートやSentinelサポート、スクリプト実行、イベント駆動が可能。<br>$ npm install ioredis → インストール<br>server.js<br>const Redis = require('***');<br>const express = require('express');<br>const app = express();<br>const redis = new Redis({ → Redis接続部分。インスタンス作成時に接続先情報を渡す<br>&emsp;port: 6379,<br>&emsp;host: 'localhost',<br>&emsp;password: process.env.REDIS_PASSWORD, → 環境変数にパスワードを渡す<br>&emsp;enableOfflineQueue: false → false：Redis利用に関わらずサーバーが起動するのを防ぐ<br>});<br>app.get('/', (req, res) => {<br>&emsp;res.status(200).send('hello world');<br>});<br>app.get('user/:id', (req, res) => {<br>&emsp;res.status(200).send(req.params.id);<br>});<br>redis.once('ready', () => { → サーバー立ち上げ（1度しか行わないので'on'ではなく'once'）。利用可能で発行されるreadyイベントに処理を紐づけ<br>&emsp;try {<br>&emsp;&emsp;app.listen(3000, () => {<br>&emsp;&emsp;&emsp;console.log('start listening');<br>&emsp;&emsp;});<br>&emsp;} catch (err) {<br>&emsp;&emsp;console.error(err);<br>&emsp;&emsp;process.exit(1);<br>&emsp;}<br>});<br>redis.on('error', (err) => {<br>&emsp;console.error(err);<br>&emsp;process.exit(1);<br>});`},
{target:`process.env`, content:`Node.jsで環境変数にアクセスするためのオブジェクト。<br>パスワードのようなクレデンシャルな情報をコードに渡すには環境変数を利用する。<br>***.***.DB_HOST：データベースホストのURL<br>***.***.REDIS_PASSWORD：Node.jsアプリケーションで環境変数REDIS_PASSWORDにアクセスするためのプロパティで、Redisサーバーに接続する際のパスワードを含む環境変数。コードに直接パスワードを記述せずに、環境変数からセキュアに取得できる。`},
{target:`process.exit`, content:`Node.jsプロセスを異常終了させるためのメソッド。<br>引数には終了コードを指定。<br>&lt;主な終了コード&gt;<br>・0：正常終了を示す。通常はエラーなしでプログラムが完了した場合に使用<br>・1：一般的な異常終了を示す。エラーが発生したか、または予期しない条件が発生した場合に使用<br>・2：コマンドライン引数が不正であるなど、不正な使用方法が原因でプログラムが終了した場合に使用<br>redis.on('error', (err) => {<br>&emsp;console.error(err);<br>&emsp;process.exit(1);<br>});`},
{target:`環境変数`, content:`オペレーティングシステムが管理する変数で、アプリケーションの設定情報を外部から提供するために使用。`},
{target:`クレデンシャル`, content:`システムやサービスにアクセスするための認証情報。<br>ユーザー名やパスワード、APIキー、トークンなど。これらの情報を使用して、システムはユーザーやアプリケーションの身元を確認し、適切なアクセス権を付与する。`},
{target:`ioredis enableOfflineQueue`, content:`ioredisの設定オプション。Redisサーバーとの接続が切れた際にコマンドをキューに保存するかどうかを制御。<br>true（デフォルト）：Redisサーバーとの接続が切れている間に送信されたコマンドをキューに保存し、接続が回復した後に再送信<br>false：接続が切れている間に送信されたコマンドを即座に失敗させる。これによりRedisが利用できない状況でサーバーが起動するのを防ぐ`},
{target:`ioredis once`, content:`ioredisライブラリで提供されるイベントリスナーを登録するためのメソッド。<br>指定されたイベントが最初に発生したときにのみコールバック関数を実行。<br>redis.***(eventName, listener) → eventNameはイベント（ioredis イベント参照）`},
{target:`ioredis on`, content:`ioredisライブラリで提供されるイベントリスナーを登録するためのメソッド。<br>指定されたイベントが最初に発生したときにコールバック関数を実行。<br>ioredis.***(eventName, listener) → eventNameはイベント（ioredis イベント参照）`},
{target:`ioredis イベント`, content:`ioredisでよく使用されるイベント。<br>redis.on(eventName, listener) → eventNameはイベントを示す<br>&lt;主なイベント&gt;<br>・'connect'：Redisサーバーへの接続が確立されたときに発生<br>・'ready'：Redisクライアントが使用可能な状態になったときに発生<br>・'error'：エラーが発生したときに発生<br>・'close'：Redis接続が閉じられたときに発生<br>・'reconnecting'：Redisクライアントが再接続中であるときに発生<br>・'end'：Redis接続が終了したときに発生<br>・'message'：RedisのPUB/SUBモードでメッセージが受信されたときに発生<br>・'subscribe'：RedisのPUB/SUBモードでチャンネルがサブスクライブされたときに発生<br>・'unsubscribe'：RedisのPUB/SUBモードでチャンネルのサブスクリプションが解除されたときに発生<br>・'monitor'：Redisのモニターモードでコマンドが実行されたときに発生`},
{target:`ioredis set`, content:`ioredisのメソッド。Redisデータベースにキーと値のペアを保存する。<br>（例：サーバー起動時に初期化処理でユーザーのデータを作成し、そのデータを/usersで表示）。<br>redis.***(key, value, [callback]) → key：保存するデータのキー、value：値、callback：処理完了時に呼び出されるコールバック関数<br>server.js<br>const Redis = require('ioredis');<br>const express = require('express');<br>const app = express();<br>const redis = new Redis({ → Redis接続部分。インスタンス作成時に接続先情報を渡す<br>&emsp;・・・<br>});<br>const init = async () => { → Redisに初期データをセット<br>&emsp;await Promise.all({ → Promise.allで同時にセット<br>&emsp;&emsp;redis.set('users:1', JSON.stringify({ id: 1, name: 'alpha' })),<br>&emsp;&emsp;redis.set('users:2', JSON.stringify({ id: 2, name: 'bravo' })),<br>&emsp;&emsp;redis.set('users:3', JSON.stringify({ id: 3, name: 'charlie' }))<br>});<br>・・・<br>redis.once('ready', async() => {<br>&emsp;try {<br>&emsp;&emsp;await init(); → initを実行<br>&emsp;&emsp;・・・<br>});<br>・・・<br>$ node server.js<br>docker run -it --net host redis redis-cli -h localhost -p 6379<br>localhost:6379> key *<br>1) 'users:3'<br>2) 'users:2'<br>3) 'users:1'<br>localhost:6379> get users:1<br>'{\'id\':1,\'name\':\'alpha\'}'`},
{target:`ioredis get`, content:`ioredisのメソッド。Redisデータベースから指定されたキーに関連付けられた値を取得。<br>（例：ユーザーIDを指定して取得する/user/:idを作成）。<br>redis.***(key, [callback]) → key：取得したいデータのキー、callback：処理完了時に呼び出されるコールバック関数<br>server.js内、app.listenの前に追記<br>app.get('/user/:id', async (req, res) => {<br>&emsp;try {<br>&emsp;&emsp;const key = 'users:' + req.params.id;<br>&emsp;&emsp;const val = await redis.***(key);<br>&emsp;&emsp;const user = JSON.parse(val);<br>&emsp;&emsp;res.status(200).json(user);<br>&emsp;} catch (err) {<br>&emsp;&emsp;console.error(err);<br>&emsp;&emsp;res.status(500).send('internal error');<br>&emsp;}<br>});`},
{target:`ioredis scanStream`, content:`ioredisのメソッド。Redisデータベースのキーをスキャンするためのストリームを提供。<br>大量のキーを一度に取得することができ、メモリ効率が向上する（例：ユーザーデータをすべて取得する/usersを作成）。<br>const stream = redis.***(options) → options：スキャンのオプションを指定するオブジェクト。デフォルトは空オブジェクト{}<br>server.js内、app.listenの前に追記<br>app.get('/users', async (req, res) =>{<br>&emsp;try {<br>&emsp;&emsp;const stream = redis.***({<br>&emsp;&emsp;&emsp;match: 'users:*', → 'users:'で始まるキーのみをスキャン<br>&emsp;&emsp;&emsp;count: 2 → 1回の呼出しで2つ取出す<br>&emsp;&emsp;});<br>&emsp;&emsp;const users = [];<br>&emsp;&emsp;for await (const resultKeys of stream) {<br>&emsp;&emsp;&emsp;for (const key of resultKeys) {<br>&emsp;&emsp;&emsp;&emsp;const value = await redis.get(key);<br>&emsp;&emsp;&emsp;&emsp;const user = JSON.parse(value);<br>&emsp;&emsp;&emsp;&emsp;users.push(user);<br>&emsp;&emsp;&emsp;}<br>&emsp;&emsp;}<br>&emsp;&emsp;res.status(200).json(users);<br>&emsp;} catch (err) {<br>&emsp;&emsp;console.error(err);<br>&emsp;&emsp;res.status(500).send('internal error');<br>&emsp;}<br>});`},
{target:`ページング処理`, content:`大量のデータを複数のページに分割して表示するための方法。<br>ウェブアプリケーションやデータベースクエリなどで使用。ユーザーは大量のデータを一度に表示せず、ページごとにデータを見ることができる。オフセットとリミットを使用して、特定のページのデータを取得。オフセットはデータの開始位置、リミットは各ページに表示されるデータの数。ユーザーがデータを操作するための直感的な方法を提供し、大量のデータを効果的に処理するための手段を提供するという利点がある。`},
{target:`prefix`, content:`文字列やパターンの先頭部分。*はワイルドカードとして使用され、任意の文字列にマッチする。<br>users:* → 'users:'で始まる任意の文字列`},
{target:`ioredis lrange`, content:`ioredisのメソッド。Redisのリスト（List）データ型から指定された範囲の要素を取得。<br>ページング処理（例：ユーザーの表示部分をページング処理に変更）。<br>redis.***(key, start, stop, [callback]) → key：リストのキー、start：開始インデックス、stop：終了インデックス、callback：取得した要素が渡されるコールバック関数<br>ユーザー情報をリスト型で登録<br>const init = async () => {<br>&emsp;await redis.rpush('users:list', JSON.stringify({ id: 1, name: 'alpha' }))<br>&emsp;await redis.rpush('users:list', JSON.stringify({ id: 2, name: 'bravo' }))<br>&emsp;await redis.rpush('users:list', JSON.stringify({ id: 3, name: 'charlie' }))<br>};<br>・・・<br>app.get('/users', async (req, res) => {<br>&emsp;const offset = req.query.offset ? Number(req.query.offset) : 0;<br>&emsp;const usersList = await redis.***('users:list', offset, offset + 1); → クエリパラメータにoffsetを指定すると、指定した箇所からデータを取得<br>&emsp;const users = usersList.map((user) => {<br>&emsp;&emsp;return JSON.parse(user);<br>&emsp;});<br>&emsp;return { users: users };<br>});`},
{target:`ioredis rpush`, content:`ioredisのメソッド。Redisのリスト（List）データ型の末尾に要素を追加。<br>リストの末尾に追加されるため、リストの順序は維持される。<br>redis.***(key, value1, value2, ..., [callback]) → key：リストのキー、value：追加する要素、callback：操作が完了した時に呼び出されるコールバック関数`},
{target:`ビューテンプレート`, content:`ウェブアプリケーションで動的なHTMLを生成するためのテンプレートファイル。<br>テンプレートエンジンによってデータを埋め込むことで、HTMLコンテンツを動的に生成・表示することができる。Expressは慣例的にviewディレクトリにテンプレートファイルを配置することが多い。`},
{target:`テンプレートエンジン`, content:`テンプレートファイルに動的なデータを埋め込んでHTMLを生成するツール。<br>Expressは慣例的にviewディレクトリにテンプレートファイルを配置することが多い。`},
{target:`ejs`, content:`JavaScriptコードを埋め込むことで、動的なHTMLテンプレートを生成するためのテンプレートエンジン。<br>サーバーサイドでデータをテンプレートに組み込み、動的なウェブページを簡単に作成できる。シンプルな構文と柔軟性が特徴。Expressは慣例的にviewディレクトリにテンプレートファイルを配置することが多い。<br>$ npm install *** → インストール<br>server.js<br>const path = require('path')<br>const express = require('express')<br>const app = express();<br>app.set('view engine', '***') → ビューテンプレートのエンジンを指定<br>app.get('/', (req, res) => {<br>&emsp;res.render(path.join(__dirname, 'view', 'index.ejs')); → /vier/index.ejsを描写<br>})`},
{target:`__dirname`, content:`Node.jsのグローバル変数。現在実行中のスクリプトファイルのディレクトリ名を表す。`},
{target:`ejs テンプレート`, content:`HTML内にJavaScriptコードを埋め込んで動的なコンテンツを生成。<br>JavaScriptのコードを埋め込むことができ、動的なコンテンツを生成するために条件分岐やループなどの制御構造を使用できる。シンプルで簡潔なシンタックスを持ち、HTML内に<% %>や<%= %>といった特殊なタグを使用してJavaScriptコードを埋め込むことができる。フロントエンドのJavaScriptライブラリやフレームワークと組合わせ使用することも可能。<br>index.ejs<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang='ja'&gt;<br>&lt;head&gt;<br>&emsp;&lt;meta charset='UTF-8'&gt;<br>&emsp;&lt;meta name='viewport' content='width=device-width, initial-scale=1.0'&gt;<br>&emsp;&lt;title&gt;users&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&emsp;&lt;ul&gt;<br>&emsp;&emsp;&lt;% for (const user of users) { %＞ → '&lt;% %&gt;'：JavaScriptコード埋込み。usersキーで受け取る<br>&emsp;&emsp;&emsp;&lt;li&gt;&lt;%= user.name %&gt; → '&lt;%= %&gt;'：変数出力&lt;/li&gt;<br>&emsp;&emsp;&lt;% } %&gt; → '&lt;% %&gt;'：JavaScriptコード埋込み<br>&emsp;&lt;/ul&gt;&lt;%# This is a comment %&gt; → '&lt;%# %&gt;'：コメント追加 <br>&lt;/body&gt;<br>&lt;/html&gt;<br>・・・<br>&emsp;&emsp;res.render(path.join(__dirname, 'view', 'users.ejs'), { users: users_data});<br> → users.ejsテンプレートをレンダリング、そのテンプレートにusersキーでusers_data変数を渡す。users.ejsテンプレート内では、users_data変数を使ってユーザーデータを表示`},
{target:`Express static`, content:`Expressのミドルウェア。静的ファイル（HTML、CSS、JavaScript、画像など）を簡単に配信できる。<br>指定したディレクトリ内のファイルを公開でき、クライアントからのリクエストがあった場合、Expressはそのリクエストに対応するファイルを自動的に探し、返す。<br>app.use('/static', express.***(path.join(__dirname, 'public'))); →第１引数でURLのprefix、第２引数で公開したいディレクトリのパスをexpress.***で渡す`},
{target:`Express generator`, content:`初期コードやディレクトリを生成。<br>Expressアプリケーションのスケルトン（骨組み）を自動的に生成するためのツールで、--view=ejsオプション指定で、テンプレートエンジンとしてEJSを使用するように設定。myappという名前のディレクトリが作成され、その中にExpressアプリケーションのファイルとディレクトリが生成される。生成されたアプリケーションには、EJSを使ったビューエンジンが設定され、基本的なファイル構造やルーティングなどのコードが用意される。<br>$ npx express-generator --view=ejs myapp → インストール`},
{target:`ルーターオブジェクト`, content:`Expressアプリケーション内でルーティングを行うためのオブジェクト。<br>アプリケーション内の特定のパスやURLに関連付けられ、そのパスに対するリクエストを処理するミドルウェア関数やルートハンドラーを定義。これにより、アプリケーション全体をモジュール化し、ルーティングのコードを分割して管理することができる。`},
{target:`コントローラー`, content:`ルーティングに基づいて特定のURLやAPIエンドポイントに対するリクエストを処理。<br>アプリケーション全体のロジックを制御するための機構であり、リクエストに対する適切な処理を行い、必要に応じてデータベースの操作やビジネスロジックを実行。また、処理結果をビューに渡してクライアントにレスポンスを返す役割も担う。`},
{target:`モジュール化`, content:`プログラムの構造化や管理のための手法。<br>プログラムを複数の小さな部品に分割し、それぞれの部品を独立して開発・テスト・管理できるようにする。一般的には関数やクラスなどの単位でモジュール化し、それらを適切に組み合わせることでプログラム全体を構築。<br>&lt;主な目的&gt;<br>・再利用性の向上：同じ機能や概念が複数の場所で必要とされる場合、それらを個別のモジュールとして定義することで、コードの再利用性が向上<br>・保守性の向上：モジュール単位でコードを分割することで、変更や修正を行う際に影響範囲を限定できるため、保守性が向上<br>・抽象化と隠蔽：モジュールを利用する側から見えるのは、そのモジュールが提供するインターフェースのみで、内部の実装の詳細は隠蔽され、外部からは関心のある機能に集中できる<br>・コードの構造化：モジュール化により、大規模なプログラムを小さな部品に分割することで、コードの構造がより明確になり、可読性が向上`},
{target:`Express Router`, content:`Expressのミドルウェア。Express.jsフレームワークのルーティングを簡潔に管理する機能。<br>アプリケーション内で複数のルートをグループ化し、それらをより構造化された形で管理でき、大規模なExpressアプリケーションでもルーティングを効果的に管理しメンテナンス性や可読性を向上できる。<br>&lt;主な特徴&gt;<br>・ルーティングのグループ化：ルーターオブジェクトの使用で、関連するルートをグループ化できる。アプリケーション全体の構造が明確になり、保守性が向上<br>・モジュール化：ルーターオブジェクトは独立して定義し、他のファイルからインポートできる。アプリケーションの各部分をモジュール化して管理できる<br>・ミドルウェアの適用：ルーターオブジェクトに対してミドルウェアを適用できる。特定のルートに対する共通の処理や認証を行うことができる<br>routes/api.js<br>const express = require('express');<br>const router = express.***();<br>router.get('/foo', (req, res) => {<br>&emsp;res.status(200).json({ foo: 'foo'}); → fooキーに'foo'を返す<br>});<br>router.get('/bar', (req, res) => {<br>&emsp;res.status(200).json({ bar: 'bar'}); → barキーに'bar'を返す<br>});<br>exports.router = router; → ルータオブジェクトを外部にエクスポート `},
{target:`Router get`, content:`Routerのメソッド。HTTP GETリクエストに対するルートを定義するために使用。<br>指定されたパス（またはパターン）に対するGETリクエストがあった場合に、実行される処理（コールバック関数）を定義。<br>const express = require('express');<br>const router = express.Router();<br>router.***('/foo', (req, res) => {<br>&emsp;res.status(200).json({ foo: 'foo'}); → fooキーに'foo'を返す<br>});<br>router.***('/bar', (req, res) => {<br>&emsp;res.status(200).json({ bar: 'bar'}); → barキーに'bar'を返す<br>});<br>exports.router = router;`},
{target:`exports.router`, content:`Node.jsの外部からアクセス可能なモジュールのエクスポート方法。<br>Expressアプリケーションでルーティングを定義する際に、独自のルーターモジュールを作成し、このエクスポート方法を使用して、ルーターオブジェクトをモジュール外部に公開する。これにより、他のモジュールからそのルーターオブジェクトにアクセスできるようになる。<br>const express = require('express');<br>const router = express.Router();<br>router.get('/foo', (req, res) => {<br>&emsp;res.status(200).json({ foo: 'foo'}); → fooキーに'foo'を返す<br>});<br>router.get('/bar', (req, res) => {<br>&emsp;res.status(200).json({ bar: 'bar'}); → barキーに'bar'を返す<br>});<br>***.*** = router;`},
{target:`コンフィグ`, content:`ソフトウェアやシステムの動作を制御するための設定情報。<br>コンフィグファイルや環境変数などに保存され、システムやアプリケーションが起動時や実行時にこれらの設定情報を読み込んで動作する。<br>&lt;主な用途&gt;<br>・ソフトウェアの設定：動作モード、ログレベル、タイムアウト時間など<br>・データベース接続情報：ホスト名、ポート番号、ユーザー名、パスワードなど<br>・環境設定：開発環境、ステージング環境、本番環境など`},
{target:`Node.js config`, content:`Node.jsのモジュール。Node.jsアプリケーションの設定管理を簡単に行う。<br>環境ごとに異なる設定を管理したり、設定値を一元的に管理したりすることができる。NODE_ENVの値に応じて読み込むコンフィグファイルを切替えてくれる。config/development.jsのファイルを用意すればNODE_ENV=developmentの時に、そのファイルから設定値を取得する。ただ、設定を少し変えたい場合にも修正が大きな箇所に及んでしまうことがあるため、このモジュールを利用する必要性は少なくなっている。`},
{target:`config.js`, content:`Node.jsアプリケーションにおける設定ファイルを管理するために使われるJavaScriptファイル。<br>一般に、アプリケーションの設定情報（例えば、データベース接続情報、APIキー、環境ごとの設定など）を一元管理するために使用。<br>config.js<br>const redisConfig = {<br>&emsp;port: 6379, → Redisサーバーがリスニングしているポート番号を指定。Redisはデフォルトで6379ポート使用<br>&emsp;host: 'localhost', → Redisサーバーのホスト名<br>&emsp;password: process.env.REDIS_PASSWORD, → Redisサーバーに接続する際に使用するパスワードを環境変数から読み込み<br>&emsp;enableOfflineQueue: false<br>}; → Redisクライアントのオフラインキューが有効かどうかを指定<br>exports.redisConfig = redisConfig; → redisConfigのエクスポート<br><br>const { redisConfig } = require('./config'); → config.js を読み込む<br>console.log(redisConfig.port); → 6379<br>console.log(redisConfig.host); → 'localhost'<br>console.log(redisConfig.password); → process.env.REDIS_PASSWORD の値が入る<br>console.log(redisConfig.enableOfflineQueue); → false`},
{target:`jest`, content:`JavaScriptのテストフレームワーク。<br>単体テスト、統合テスト、ユニットテストなど、さまざまな種類のテストをサポートし、簡潔で直感的な構文を提供。また、モック機能によりテスト中の外部依存関係の制御を容易にする。`},
{target:`Jest fn`, content:`Jestのメソッド。 Jest テストフレームワークで利用される関数のモックを作成。<br>テスト中に特定の関数の振る舞いを変更したり、関数が呼び出されたかどうかを追跡したりすることができる。<br>const mockFunction = ***.***();<br>mockFunction('argument'); → モックされた関数の呼び出し`},
{target:`Generator`, content:`functionに*のついた関数。yeildキーワードとnextメソッドにより複数回値を返す関数プロパティを定義可能。<br>next()メソッドを呼出すたびにyieldキーワードで返される値を順番に受け取ることができる。next()メソッドは、valueとdoneの2つのプロパティを持つオブジェクトを返す。valueプロパティは値が含まれ、doneプロパティはブール値で、反復終了時に true、それ以外はfalseを返す。<br>function* myGenerator {<br>&emsp;yield 1;<br>&emsp;yield 2;<br>&emsp;yield 3;<br>}<br>const iterator = myGenerator();<br>console.log(iterator.next()); → { value: 1, done: false }<br>console.log(iterator.next().value); → 2<br>console.log(iterator.next()); → { value: 3, done: false }<br>console.log(iterator.next()); → { value: undefined, done: true }`},
{target:`Symbol`, content:`プリミティブ型の一つ。一意かつ不変の値を表す。<br>プログラム全体で一意であり、他のデータと等しくない。<br>const foo = ***('foo');<br>const foo2 = ***('foo');<br>console.log(foo === foo); → true<br>console.log(foo === foo2); → false<br>const obj = [];<br>obj[foo] = 'foo';<br>obj[foo2] = 'foo2';<br>console.log(obj.foo); → undefined<br>console.log(obj[foo]); → foo<br>console.log(obj[foo2]); → foo2`},
{target:`デプロイ`, content:`ソフトウェアやアプリケーションを開発環境から実際の運用環境に展開すること。<br>開発者が作成したアプリケーションを、エンドユーザーがアクセス可能な形で公開するために、サーバー上で実行できる形式に変換するプロセス。アプリケーションは実際に利用可能な状態になり、ユーザーが利用できるようになる。<br>ステップ<br>ビルド：開発者が作成したソースコードやリソースを、実行可能な形式に変換。コンパイル、バンドル、圧縮などの処理が含まれる場合がある<br>テスト：ビルドされたアプリケーションをテストし、品質やパフォーマンスの問題を特定・修正する。テストは自動化されることが多く、自動テストスイートを実行して品質を確保する<br>デプロイメント：ビルドされたアプリケーションを運用環境に配置。サーバーへのファイルのコピー、設定の適用、プロセスの再起動などが含まれる<br>監視とメンテナンス：デプロイされたアプリケーションを監視し、問題が発生した場合には対応する。また、定期的なメンテナンスやアップデートも行う`},
{target:`コンパイル`, content:`プログラミング言語で書かれたソースコードを、コンピュータが理解できるバイナリ形式に変換するプロセス。`},
{target:`自動テストスイート`, content:`ソフトウェアの自動テストを実行するためのテストケースの集合。`},
{target:`Linux systemd`, content:`サーバーアプリケーションのデーモン化やプロセスの管理を行うための仕組み。<br>Node.jsアプリケーションをデプロイする際にNode.jsサーバープロセスをデーモン化しシステムの起動時に自動的に起動するように設定する。Node.jsアプリケーションをサービスとして定義し、この設定ファイル（通常は.service拡張子）にそのサービスの設定を記述する。Node.jsアプリケーションの実行コマンド、起動時の環境変数、ログの出力先などが含まれる。<br>設定ファイル<br>/etc/systemd/system/my-app.service<br>[Unit] → ユニットセクション。systemdサービスの説明や設定を含むためのセクション<br>Description=my-app → サービスの説明を指定<br><br>[Service] → サービスの実行に関する設定を含むセクション<br>Type=simple → サービスのタイプを指定。simpleは単純なフォークを行うサービスを意味する<br>Environment=NODE_ENV=production → サービスの実行時に設定する環境変数を指定。NODE_ENV環境変数をproductionに設定<br>EnvironmentFile=/etc/sysconfig/env-file → サービスの実行に使用される環境変数が記述されたファイルを指定<br>WorkingDirectory=/var/www/app → サービスが実行されるディレクトリを指定<br>ExecStart=/usr/local/bin/node /var/www/app/server.js → サービスの開始時に実行されるコマンドを指定<br>&emsp;Node.jsアプリケーションは/var/www/app/server.jsに、Nodeの実行ファイルは/usr/local/bin/nodeに配置<br>User=root → サービスが実行されるユーザーを指定。rootユーザーで実行<br>Group=root → サービスが実行されるグループを指定。rootグループで実行<br>Restart=always → サービスの再起動の条件を指定。常に再起動するように設定<br>LimitNOFILE=65535 → サービスが開くことができるファイルディスクリプタの最大数を指定<br>TimeoutStopSec=60 → サービスの停止がタイムアウトするまでの時間を指定<br><br>[Install] → インストール時の設定を含むセクション<br>WantedBy=multi-user.target → サービスがインストールされたときに有効になるターゲットを指定<br>&emsp;multi-user.targetによって、マルチユーザーモードでサービスが有効化`},
{target:`サービス`, content:`Linuxシステム上で実行されるバックグラウンドプロセスやデーモンのこと。`},
{target:`デーモン`, content:`バックグラウンドで実行されるプロセスやサービスのこと。<br>特定の機能を提供したり、システムの動作を管理したりするために利用。Webサーバーやデータベースサーバーなど。`},
{target:`フォーク`, content:`新しいプロセスを生成すること。<br>元のプロセス（親プロセス）と、新しいプロセス（子プロセス）の2つのインスタンスが作成される。親プロセスと子プロセスは同じコードを実行するが、プロセスIDや一部の状態などが異なる場合がある。Unix系のオペレーティングシステムでは、フォークシステムコールを使用して新しいプロセスを生成する。`},
{target:`rootユーザー`, content:`最高権限を持つ特別なユーザー。<br>システム上のあらゆる操作を行うための全権限が与えられる。`},
{target:`ファイルディスクリプタ`, content:`プロセスがファイルやソケット、パイプなどの入出力チャネルを識別するための番号。`},
{target:`SPA(Single Page Application)`, content:`ウェブページの初回ロード後にページ全体を再読み込みすることなく、動的にコンテンツを更新するウェブアプリケーション。<br>ユーザーに対してより速く、スムーズな体験を提供。`},
{target:`フロントエンドフレームワーク`, content:`ウェブアプリケーションやウェブサイトのユーザーインターフェースを効率的に開発するためのツールやライブラリのセット。<br>開発者は一般的な機能を迅速かつ簡単に実装できる。<br>&lt;主な特徴&gt;<br>・コンポーネントベース：再利用可能なUIコンポーネントを構築できる<br>・効率的な開発：多くの共通機能があらかじめ用意されており、開発速度が向上する<br>・一貫したデザイン：デザインパターンやスタイルガイドラインに従うことで、一貫性のあるUIを作成できる<br>・レスポンシブデザイン：デフォルトでモバイル対応の設計がされていることが多い<br>&lt;代表的なフレームワーク&gt;<br>・React：Facebookが開発した、コンポーネントベースのライブラリ。仮想DOMを使用して高速なUI更新を実現する<br>・Vue：軽量で柔軟なフレームワーク。シンプルさと使いやすさが特徴<br>・Angular：Googleが開発したフル機能のフレームワーク。厳密な構造と豊富な機能を持つ<br>・Bootstrap：Twitterが開発したCSSフレームワーク。レスポンシブデザインを容易に実現できる`},
{target:`React`, content:`高性能で再利用可能なユーザーインターフェースを効率的に構築するためのJavaScriptライブラリ。<br>Facebookが開発・維持しており、コンポーネントベースの設計と仮想DOMを利用して、スムーズで高性能なUIを実現。シングルページアプリケーション（SPA）の高速でインタラクティブなウェブアプリケーションの構築に最適。<br>&lt;主な特徴&gt;<br>・コンポーネントベース：UIを小さな再利用可能なコンポーネントに分割して構築<br>・仮想DOM：仮想DOMを使用して効率的にUIの更新を行い、実際のDOM操作を最小限に抑える<br>・単方向データフロー：データの流れが一方向であるため、予測可能で管理しやすい状態管理が可能<br>・エコシステム：広範なコミュニティと豊富なサードパーティライブラリがサポートされているため、さまざまな機能を簡単に拡張できる`},
{target:`DOM(Document Object Model)`, content:`HTMLやXMLドキュメントの構造をプログラムから操作するためのAPI。<br>ドキュメントの内容をツリー構造として表現し、JavaScriptなどのプログラミング言語を使って、ドキュメントの内容や構造、スタイルを動的に変更することが可能。<br>&lt;主な特徴&gt;<br>・ツリー構造：ドキュメント全体を親子関係を持つノードのツリーとして表現。各要素や属性、テキストがノードとして扱う<br>・操作可能なインターフェース：JavaScriptなどの言語を使って、ノードの追加、削除、変更<br>・リアルタイムの更新：DOMを通じて行われた変更は、即座にウェブページに反映`},
{target:`仮想DOM`, content:`リアルDOMの軽量なコピーをメモリ上に保持し、UIの変更を効率的に管理・更新するための技術。<br>リアルDOMと比べて操作が高速であり、Reactなどのライブラリで使用。Reactではコンポーネントの再レンダリング時に差分を算出しリアルDOMに反映することでUIを効率的に更新する。`},
{target:`モノレポ(Monorepo)`, content:`複数のプロジェクトやパッケージを単一のリポジトリ内で管理する手法。<br>コードの共有や依存関係の管理が効率的になる。<br>&lt;主な特徴&gt;<br>・単一リポジトリ：すべてのプロジェクトやパッケージが一つのリポジトリに収められる<br>・コード共有：プロジェクト間でコードを簡単に共有でき、再利用性が高まる<br>・一貫したバージョン管理：すべてのプロジェクトが同じバージョン管理システムで統一される<br>・依存関係の管理：プロジェクト間の依存関係を簡単に管理できる<br>・効率的なコラボレーション：チーム間の協力が容易になり、変更の影響を把握しやすくなる<br>・統一されたビルドプロセス：ビルドやテストの設定を統一でき、CI/CDパイプラインがシンプルになる`},
{target:`npm workspaces`, content:`複数のパッケージを単一のリポジトリで効率的に管理するための機能。<br>プロジェクトの依存関係やスクリプトを簡単に統合・管理できる。package.jsonでリポジトリ全体を管理し、各ルートディレクトリにpackage-lock.jsonが配置され管理する。ルート直下のpackage.jsonで管理したいパッケージを指定する。フロントエンド・バックエンドそれぞれのアプリケーションに必要なモジュールを管理するため、packages/frontendとpackages/backend直下にもそれぞれのpackage.jsonが配置する。packages/*でpackagesディレクトリ以下すべてをターゲットに指定できる。<br>ルートディレクトリでnpm installを実行すると、配下のパッケージすべてのインストールが実行できる。<br>サーバーの起動では、start listeningと直接ファイルを指定してもよいが、npm scriptsにまとめるとより便利になる。<br>配下のパッケージは-wオプションでルートディレクトリから呼び出しが可能。<br>&lt;主な特徴&gt;<br>・複数パッケージの管理：一つのリポジトリ内で複数のnpmパッケージを管理できる<br>・依存関係の共有：ルートプロジェクトと各ワークスペース間で依存関係を共有し、重複を避けれる<br>・一括スクリプト実行：ルートから各ワークスペースのスクリプトを一括で実行できる<br>・バージョン管理の一元化：各パッケージのバージョンを一元管理し、同期できる<br>package.json<br>{<br>&emsp;'privete': true,<br>&emsp;'workspaces': [<br>&emsp;&emsp;'packages/*'<br>&emsp;],<br>&emsp;'scripts': {<br>&emsp;&emsp;'start': 'node server.js'<br>&emsp;}<br>}`},
{target:`フロントエンド`, content:`面表示や入力・操作の受け付けなど、主に利用者が直接触れる部分。<br>ユーザーのアクション等に応じてバックエンドのAPIを呼び出したり、HTMLなどの見た目を操作する。`},
{target:`バックエンド`, content:`フロントエンドから受け取ったデータを処理・保存したり、フロントエンドの要求に応じてデータや機能を提供する構成要素。`},
{target:`npx`, content:`npmパッケージを便利に実行するためのツールで、ローカルにインストールされていないパッケージを一時的に実行したり、プロジェクト内の依存関係を手軽に実行するのに役立つ。<br>開発作業が効率化され、パッケージの管理が容易になる。<br>&lt;利点&gt;<br>・インストール不要：一時的に必要なパッケージをローカルにインストールせずに実行できる<br>・便利なバージョン管理：複数のバージョンのパッケージをプロジェクトごとに使い分けることができる<br>・ローカル依存の優先実行：グローバルにインストールされているものより、プロジェクトのローカルにインストールされているパッケージを優先的に実行できる<br>・ローカルにインストールされていないパッケージの実行例<br>$ *** create-react-app my-app → create-react-appを一時的にインストールし、ディレクトリ my-app に新しいReactアプリケーションを作成する`},
{target:`npx create-react-app`, content:`Reactアプリケーションのプロジェクトを素早く作成するためのコマンド。<br>このコマンドを実行すると、Reactアプリの雛形が自動的に生成され、開発を開始する準備が整う。<br>&lt;主な特徴&gt;<br>・プロジェクトの自動作成：Reactアプリの基本的なファイルやディレクトリ構造が自動的に生成される<br>・開発環境のセットアップ：ビルドや開発用サーバーのセットアップが自動化され、開発をすぐに始められる<br>・最新のReactテンプレートの利用：Reactチームによってメンテナンスされ、常に最新のReactテンプレートを提供される<br>$ *** *** *** packages/frontend → 新しいReactアプリケーションを作成<br>$ npm start -w packages/frontend → packages/frontendディレクトリ内のReactフロントエンドプロジェクトを開始<br>directory/ → 新しいReactディレクトの構成<br>&emsp;packages/ → モノレポのルートディレクトリ<br>&emsp;&emsp;frontend/ → フロントエンドプロジェクトのディレクトリで、Reactアプリケーションの構成を含む<br>&emsp;&emsp;&emsp;public/ → 公開される静的ファイルが配置されるディレクトリ。faviconやHTMLファイルなど<br>&emsp;&emsp;&emsp;&emsp;favicon.ico → ファビコン（Webサイトのアイコン）の画像ファイル<br>&emsp;&emsp;&emsp;&emsp;index.html → ReactアプリケーションのエントリーポイントとなるHTMLファイル<br>&emsp;&emsp;&emsp;&emsp;logo192.png → アプリケーションのロゴ画像<br>&emsp;&emsp;&emsp;&emsp;logo512.png → アプリケーションのロゴ画像<br>&emsp;&emsp;&emsp;&emsp;manifest.json → Progressive Web App（PWA）の設定を記述するマニフェストファイル<br>&emsp;&emsp;&emsp;&emsp;robots.txt → 検索エンジンクローラーに対するWebサイトのクローリングの設定を記述するロボットスタンダードファイル<br>&emsp;&emsp;&emsp;src/ → Reactアプリケーションのソースコードが格納されるディレクトリ<br>&emsp;&emsp;&emsp;&emsp;App.css →  アプリケーションのスタイルシートファイル<br>&emsp;&emsp;&emsp;&emsp;App.js → Reactアプリケーションのメインコンポーネントで、アプリケーションのエントリーポイント<br>&emsp;&emsp;&emsp;&emsp;App.test.js → App.jsコンポーネントのユニットテストファイル<br>&emsp;&emsp;&emsp;&emsp;index.css → アプリケーション全体のスタイルシートファイル<br>&emsp;&emsp;&emsp;&emsp;index.js → ReactアプリケーションをDOMにレンダリングするエントリーポイントのJavaScriptファイル<br>&emsp;&emsp;&emsp;&emsp;logo.svg → アプリケーションのロゴ画像のSVGファイル<br>&emsp;&emsp;&emsp;&emsp;reportWebVitals.js → Web Vitalsのレポートを提供するためのJavaScriptファイル<br>&emsp;&emsp;&emsp;&emsp;setupTests.js → テストの設定を行うためのJavaScriptファイル<br>&emsp;&emsp;&emsp;package.json<br>&emsp;&emsp;backend/~~~<br>&emsp;package.json  → プロジェクトの設定や依存関係が記述されたファイルで、npmパッケージのメタデータを定義<br>&emsp;package-lock.json → npmパッケージの正確なバージョンや依存関係がロックされた状態を保存するためのファイル`},
{target:`npm start -w`, content:`npmスクリプトを使用して、指定されたパッケージ内のプロジェクトを開始するコマンド。<br>通常はプロジェクトの開発サーバーを起動。-wオプションは、ワークスペース（モノレポ内の特定のディレクトリ）を指定。<br>$ *** *** *** packages/frontend → 指定されたパッケージ内のフロントエンドプロジェクトを開始`},
{target:`package-lock.json`, content:`npmパッケージの依存関係の状態を固定するためのファイル。<br>このファイルは通常、npm installコマンドを実行すると自動的に生成される。npmパッケージの依存関係を追加または変更する際には、このファイルが更新される。<br>&lt;主な役割&gt;<br>・依存関係のバージョンロック：各npmパッケージの正確なバージョンを記録し、そのバージョンが再現可能な状態に保つ<br>・再現性の確保：プロジェクトを再構築する際に、依存関係が変更されないようにする。開発環境やビルド環境の再現性が確保される<br>・パフォーマンスの向上：パッケージの再インストールを最小限に抑え、依存関係のロックされた状態を維持することで、インストールプロセスの高速化に寄与`},
{target:`エントリーポイント`, content:`プログラムの実行が開始される場所を指す特定のファイルや関数。<br>一般的に、アプリケーションのメインとなるファイルや関数であり、プログラムの実行が始まる地点として機能。例えば、Webアプリケーションの場合、HTMLファイル内の&lt;script&gt;タグで指定されたJavaScriptファイルや、Node.jsアプリケーションの場合、index.jsなどがエントリーポイントとなる。エントリーポイントは、アプリケーションの動作を制御し、他のファイルやモジュールを呼び出して処理を開始する。`},
{target:`メタデータ`, content:`データに関する情報を記述するデータ（ただしデータそのものではない）。<br>主にデータの内容や特性、属性に関する情報を提供。例えば、書類の作成日時やファイルサイズ、画像の解像度や作成者、音楽ファイルの曲名やアーティストなど。メタデータは、データの管理や整理、検索、分類などの目的で利用。`},
{target:`PWA(Progressive Web App)`, content:`ウェブアプリケーションの新しい開発手法であり、ウェブ技術を使用してネイティブアプリのようなユーザーエクスペリエンスを提供することを目指す。<br>&lt;主な特徴&gt;<br>・プログレッシブ：すべてのユーザーに機能し、ネイティブアプリと同様のユーザーエクスペリエンスを提供<br>・レスポンシブ：さまざまなデバイスや画面サイズに適応し、適切に表示される<br>・オフライン動作：オフラインで動作し、不安定なネットワーク環境でも使用。Service Workerなどの技術を使用してキャッシュやオフラインデータの管理が可能<br>・アプリのような振る舞い：ホームスクリーンにアイコンを追加し、フルスクリーンで起動でき、プッシュ通知を送信するなど、ネイティブアプリと同様の機能を提供<br>・安全性：HTTPSを使用して通信し、ユーザーの情報やプライバシーを保護`},
{target:`マニフェストファイル`, content:`Progressive Web App（PWA）の機能の1つであり、アプリの外観や動作を定義するためのJSON形式のファイル。<br>このファイルには、アプリ名、アイコン、スタートURLなどの情報が含まれる。主な目的は、ウェブアプリケーションをホームスクリーンに追加する際に、アプリの見た目や動作を指定すること。マニフェストファイルによって、ユーザーエクスペリエンスを向上させ、ネイティブアプリのような体験を提供。`},
{target:`検索エンジンクローラー`, content:`インターネット上のウェブページを自動的に巡回し、その内容を収集して検索エンジンのインデックスに追加するプログラム。<br>他に「ロボット」「スパイダー」とも呼ばれる。検索エンジンはこれらを使用して、ウェブサイトやウェブページの情報を収集し、検索結果に表示。リンクをたどってウェブページを発見し、HTMLや他の形式のコンテンツを解析して、キーワードやメタデータなどの情報を収集。`},
{target:`クローリング`, content:`検索エンジンのクローラーがウェブページを自動的に巡回し、そのコンテンツを収集するプロセスです。<br>クローリングウェブ上のリンクをたどって新しいページを発見し、それらのページをダウンロードし検索エンジンのインデックスに追加。このプロセスによって、検索エンジンは最新の情報を収集し、ユーザーが検索クエリを行った際に適切な結果を提供。`},
{target:`Web Vitals`, content:`ウェブページのパフォーマンスとユーザーエクスペリエンスを測定するための指標の集合。<br>これらの指標は、Googleによって定義され、ウェブページの読み込み速度、視覚的な安定性、インタラクティブ性などの要素を評価。具体的には、LCP（Largest Contentful Paint）、FID（First Input Delay）、CLS（Cumulative Layout Shift）など。ウェブページの改善とユーザーエクスペリエンスの向上を目指し、開発者がパフォーマンスを測定し、最適化するためのガイドラインになっている。`},
{target:`React App.js`, content:`Reactアプリケーションにおける主要なコンポーネントファイルの一つで、アプリケーション全体の構造やルーティング、状態管理を担う。<br>ECMAScript modules記法で記載され、App関数をexportし、returnの中にJSXによるHTMLを記述。フロントエンドのJavaScript開発では、実行前にビルドを行うのが一般的で、Reactを利用する時は、実行前にJSXをブラウザが実行可能なJavaScriptにビルドする。また、svgファイルやcssファイルもReactと同様ブラウザが解釈可能な形になるようにビルドが必要。<br>import { useState } from 'react'; → 値を保持するuseState関数読み込み<br>import './App.css';<br>function App() { → Reactコンポーネントとして定義されJSXのHTMLを返す<br>&emsp;const users = ['alpha', 'bravo', 'charlie', 'delta'];<br>&emsp;const [inputText, setInputText] = useState('');<br>&emsp;const userList = user.map((user) => {<br>&emsp;&emsp;return &lt;li key={user}&gt;{user}&lt;/li&gt;; → 動的表示の埋め込み。各要素に一意のkey属性としてuserを設定<br>&emsp;});<br>&emsp;const handleSubmit = (event) => {<br>&emsp;&emsp;event.preventDefault(); → イベントのデフォルトの動作をキャンセルするためのメソッド。デフォルトの動作を防止する<br>&emsp;&emsp;console.log('handle submit', inputText);<br>&emsp;};<br>&emsp;const handleChange = (event) => {<br>&emsp;&emsp;setInputText(event.target.value); → setInputTextでinputタグの入力内容をevent.target.valueに格納<br>&emsp;};<br>&emsp;return (<br>&emsp;&emsp;&lt;div className='App'&gt; → classプロパティは直接扱えないため、classNameプロパティを利用<br>&emsp;&emsp;&emsp;&lt;ul&gt;{userlist}&lt;/ul&gt; → 変数埋め込み<br>&emsp;&emsp;&emsp;&lt;form onSubmit={handleSubmit}&gt; → フォームが送信されたときに実行されるイベントハンドラを指定<br>&emsp;&emsp;&emsp;&emsp;&lt;input type='text' onChange={handleChange} /&gt; → input要素追加。onChangeプロパティにハンドラーを追加<br>&emsp;&emsp;&emsp;&emsp;&lt;button type='submit'&gt;追加&lt;/button&gt; → button要素追加<br>&emsp;&emsp;&emsp;&lt;/form&gt;<br>&emsp;&emsp;&emsp;&lt;div&gt;入力値: {inputText}&lt;/div&gt;<br>&emsp;&emsp;&lt;/div&gt;<br>&emsp;);<br>}<br>export default App; → Appコンポーネントを他のファイルで使用できるようにエクスポート`},
{target:`React {variable}`, content:`JSX内でJavaScriptの変数や式を埋め込むための構文。<br>JSX内で波括弧 {} を使用して、JavaScriptの変数や式を評価して埋め込む。コンポーネントの出力に動的なデータを含めることができる。<br>import React from 'react';<br>function Greeting() {<br>&emsp;const name = 'Alice';<br>&emsp;return &lt;h1&gt;Hello, {name}! &lt;/h1&gt;; → 'Hello, Alice!'と表示<br>}<br>export default Greeting;`},
{target:`React key`, content:`リストをレンダリングする際に各要素を一意に識別するために使用される特別な属性。<br>Reactが差分としてどのアイテムが変更、追加、または削除されたかを効率的に検出し、再レンダリングのパフォーマンスを最適化するのに役立つ。keyにはユニークな値を設定。リストの要素を追加、削除、または並べ替えする場合、Reactはどの要素が変更されたかを正確に把握できず、無駄な再レンダリングやバグの原因になる。これを使用することで、Reactは効率的に要素を管理し、パフォーマンスを向上させることができる。<br>&lt;ポイント&gt;<br>・一意であることが重要：リスト内で一意でなければならない。通常、各アイテムの固有のIDを使用<br>・再レンダリングの効率化：Reactは要素の位置の変更を検出し、必要最小限の再レンダリングを行うことができる<br>・配列内で使用：リスト（配列）内の兄弟要素に対してのみ必要。リスト外の要素にkeyを指定しても意味がない`},
{target:`React onSubmit`, content:`Reactにおいて、フォームが送信されたときに実行されるイベントハンドラを指定するための属性。<br>通常、フォームが送信されたときに行うべき処理を関数として指定。<br>&lt;ポイント&gt;<br>・フォームの送信処理：属性に指定された関数が、フォームが送信されたときに実行<br>・イベントオブジェクトの利用：イベントハンドラ内でevent.preventDefault()を使用することで、フォームのデフォルトの送信動作をキャンセルすることができる<br>・Reactでの使用：フォームの送信処理を制御することができる`},
{target:`React onChange`, content:`Reactにおいてフォーム要素の値が変更されたときに発生するイベント。<br>主に&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;などのフォーム要素に適用。ユーザーがフォーム要素に入力を行うたびに、イベントがトリガーされる。イベントが発生した要素の現在の値はevent.target.valueに格納される。<br>&lt;ポイント&gt;<br>・動的な入力の監視：ユーザーがフォーム要素に入力するたびに呼び出され、入力値の変更を検知<br>・コントロールされたコンポーネント：Reactでは通常、フォーム要素の値をステートで管理し、これを使用して値の変更をキャッチする方法が推奨`},
{target:`event.target.value`, content:`ReactやJavaScriptでイベントハンドラ内で使用される、イベントが発生した要素の現在の値を取得する。<br>&lt;ポイント&gt;<br>・イベントオブジェクトのプロパティ：eventオブジェクトからtargetプロパティを使用して、イベントが発生した要素にアクセスできる<br>・フォーム要素の値の取得：target.valueを使用することで、フォーム要素の現在の値を取得できる`},
{target:`React useState`, content:`React関数。関数コンポーネント内で状態を管理するために使用。<br>Reactコンポーネント内で状態を宣言し、その状態を動的に更新することができる。呼び出すと配列を返し、保持する変数は配列の[0]、変数を保持するための関数は配列の[1]に格納される。<br>[保持する変数, 変数をほじするための関数] = useState(初期値);<br>setInputText関数を使用して、inputText状態を更新する。`},
{target:`React setInputText`, content:`Reactで状態を更新する関数。<br>通常、useState関数と一緒に使用され、状態を更新するための更新関数として定義される。状態を制御し、コンポーネントの動的な振る舞いを実装することができる。<br>&lt;ポイント&gt;<br>・状態の更新関数：状態を更新するための関数<br>・状態の制御：テキスト入力やフォーム要素の値を制御<br>・useState関数との使用：useState関数と一緒に使用し、状態を宣言および初期化し、その後の更新を管理する`},
{target:`コンポーネント`, content:`HTMLの要素の塊。<br>ユーザーインターフェース（UI）の一部を構成する独立した再利用可能な部品のこと。`},
{target:`JSX(JavaScript XML)`, content:`Reactで使用される構文拡張で、JavaScriptからテンプレートエンジンのようなHTMLに近い記述を可能にする。<br>UIコンポーネントの構造を視覚的に表現しやすくなり、コードの可読性が向上。<br>&lt;主な特徴&gt;<br>・HTMLのような構文：HTMLに似ており、タグを使ってUI要素を記述。UI構造を簡単に把握できる<br>・JavaScript変換：JavaScriptの構文拡張であり、ブラウザが理解できるJavaScriptにコンパイルされる。React.createElement()関数を使ってDOM要素を生成<br>・式の埋め込み：JavaScriptの式を使用でき、中括弧 {} を使って、変数や関数の結果を埋め込む<br>import React from 'react';<br>function Welcome(props) {<br>&emsp;return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; → HTMLタグと同じ形式で要素を記述。中括弧を使ってJavaScriptの式を埋め込むことができる<br>}<br>function App() {<br>&emsp;return (<br>&emsp;&emsp;&lt;div&gt;<br>&emsp;&emsp;&emsp;&lt;Welcome name='Alice' /&gt; → 他のコンポーネントをタグとして使用<br>&emsp;&emsp;&emsp;&lt;Welcome name='Bob' /&gt;<br>&emsp;&emsp;&lt;/div&gt;<br>&emsp;);<br>}<br>export default App;`},
{target:`ビルド`, content:`ソースコードやその他のリソースをコンピュータが実行可能な形式に変換するプロセス。<br>Reactアプリケーションのビルドプロセスは、ソースコードのコンパイル、依存関係のバンドル、コードのミニファイ、静的ファイルの生成からなる。<br>&lt;ステップ1&gt;プロジェクトの作成<br>$ npx create-react-app my-app → create-react-appを使って新しいReactプロジェクトを作成<br>$ cd my-app<br>&lt;ステップ2&gt;アプリケーションの開発<br>import React from 'react';<br>function App() {<br>&emsp;return (<br>&emsp;&emsp;&lt;div className='App'&gt;<br>&emsp;&emsp;&emsp;&lt;header className='App-header'&gt;<br>&emsp;&emsp;&emsp;&emsp;&lt;h1>Hello, React!&lt;/h1&gt;<br>&emsp;&emsp;&emsp;&lt;/header&gt;<br>&emsp;&emsp;&lt;/div&gt;<br>&emsp;);<br>}<br>export default App;<br>&lt;ステップ3&gt;ビルドの実行<br>$ npm run build<br>→ ビルドコマンドを実行し最適化されたプロダクションビルドを作成。buildディレクトリが作成され、その中に最適化されたバンドルが生成される<br>&lt;ステップ4&gt;ビルドのデプロイ<br>buildディレクトリ内のファイルは、静的ファイルとしてWebサーバーにデプロイすることができる（例：NetlifyやVercelなどのホスティングサービスを使ってデプロイ）`},
{target:`Babel`, content:`JavaScriptのコンパイラであり、最新のJavaScriptコードを古いブラウザでも動作するように変換するツール。<br>動作にはビルドしてブラウザが実行可能なJavaScriptへと変換する必要がある。`},
{target:`TypeScript`, content:`静的型付けをサポートし、コードの品質向上と開発者の生産性向上を目的とし、コードは、最終的に標準的なJavaScriptにコンパイルされ、ブラウザやNode.js環境で実行可能。<br>動作にはビルドしてブラウザが実行可能なJavaScriptへと変換する必要がある。`},
{target:`コンポーネント分割`, content:`Reactのアプリケーション開発において、コードを再利用しやすく、管理しやすくするためにUI要素を小さな、独立したコンポーネントに分ける手法。<br>各コンポーネントが特定の機能や役割を持ち、複雑なアプリケーションを構築する際にコードの整理が容易になる。<br>import React from 'react';<br>import User from './User'; → コンポーネント User 読み込み<br>import TextInput from './TextInput'; → コンポーネント TextInput 読み込み<br>function App() {<br>&emsp;const users = ['alpha', 'bravo', 'charlie', 'delta'];<br>&emsp;const userList = users.map((user) =&gt; {<br>&emsp;&emsp;return &lt;User key={user} name={user} /&gt;; → コンポーネント User レンダリング（引数：name={user}）<br>&emsp;});<br>&emsp;return (<br>&emsp;&emsp;&lt;div&gt;<br>&emsp;&emsp;&emsp;&lt;ul&gt;{userList}&lt;/ul&gt;<br>&emsp;&emsp;&emsp;&lt;TextInput /&gt; → コンポーネント TextInput レンダリング<br>&emsp;&emsp;&lt;/div&gt;<br>&emsp;);<br>}<br>export default App;<br>User.js → コンポーネント User の作成<br>import React from 'react';<br>const User = ({ name }) =&gt; &lt;li&gt;{name}&lt;/li&gt;;<br>export default User;<br>TextInput.js → コンポーネント TextInput の作成<br>import React from 'react';<br>const TextInput = () =&gt; &lt;input type='text' /&gt;;<br>export default TextInput;`},
{target:`APIコール`, content:`アプリケーションがAPIを通じて他のサービスやシステムとデータや機能をやり取りすること。<br>ウェブアプリケーションがサーバーからデータを取得したり、データを送信したりする際に使用される一般的な方法。`},
{target:`ホットリロード`, content:`開発中にコードを変更した際に、アプリケーションを再起動せずに即座に変更を反映させる機能。<br>開発者は変更結果を即座に確認できるため、開発の効率が向上。`},
{target:`fetch`, content:`HTTPリクエストなどをPromiseで扱えるAPI。<br>ウェブサーバーに対してHTTPリクエストを送信し、その応答を処理するために使用。主に、データの取得（GET）や送信（POST）などに用いられる。<br>App.js → フロントエンドに組込み<br>const getUsers = aync () => {<br>&emsp;const response = await ***('/api/users'); → urlの情報を取得<br>&emsp;const body = response.json(); → json関数でbodyの内容をオブジェクトとして取得<br>&emsp;return body;<br>}<br>function App(){<br>&emsp;const [users, setUsers] = useState(['alpha', 'bravo', 'charlie', 'delta']);<br>&emsp;const [inputText, setInputText] = useState('');<br>&emsp;getUsers() → ユーザー情報取得関数を呼出す<br>&emsp;&emsp;.then((data) => console.log(data))<br>&emsp;&emsp;.catch((error) => console.error(error));<br>&emsp;const userList = users.map((user) => {<br>&emsp;&emsp;return &lt;user key={user} name={user} /&gt;;<br>&emsp;});`},
{target:`CORS(Cross-Origin Resorce Sharing)`, content:`ウェブブラウザーのセキュリティメカニズムの一部であり、異なるオリジン（ドメイン、プロトコル、ポート）間でのリソース共有を制御する仕組み。<br>ウェブサイトやウェブアプリケーションがクライアントサイドで他のサーバーからデータを取得する際に、セキュリティ上のリスクを制御。ポリシーに違反するリクエストは、ブラウザーによってブロックされる。ブラウザの基本的な操作は同じOriginのみに限定される（Same-origin policy）ため、異なるOriginのリソースにアクセスを許可させる際に利用される。Originの構成要素は、scheme + domain(host) + port で、具体的な例としては、http://localhost:8000の部分。フロントエンドとバックエンドが異なるOrigin（例えば、ポートが異なるなど）の場合、①Proxy を導入してドメインを同じにする、②Access-Control-Allow-Origin ヘッダーを付与する、ことが必要。`},
{target:`Origin`, content:`ウェブリクエストの送信元を特定するための情報。<br>通常、プロトコル（http、httpsなど）、ホスト（ドメイン名）、およびポート番号の組み合わせで表される。'https://example.com:8080'では、httpsプロトコルでexample.comというホスト名、ポート番号8080を持つサイトを表す。この情報は、CORS（Cross-Origin Resource Sharing）ポリシーや同一生成元ポリシーなどのウェブセキュリティメカニズムで使用する。`},
{target:`Scheme`, content:`URI（Uniform Resource Identifier、統一リソース識別子）の一部。<br>リソースへのアクセス方法を指定。HTTP、HTTPS、FTP、fileなど。通常、'https://'や'ftp://'などURIの先頭にある。`},
{target:`Domain(Host)`, content:`インターネット上で一意の識別子として使用されるコンピューターまたはネットワークの名前。<br>ウェブサイトの場合、ドメインはそのウェブサイトのアドレスを指定する（'example.com'や'subdomain.example.com'など）。URLの一部として見られ、ウェブサイトにアクセスするためのユニークな識別子として機能する。`},
{target:`Port`, content:`コンピューターネットワークにおいて、通信を行うための特定の番号。<br>ネットワーク上のプロセスやサービスを識別し、通信がどのプロセスやサービスに送られるかを決定する。例えば、HTTP通信は通常番号80を使用し、HTTPS通信は番号443を使用。IPアドレスと組み合わせて、通信の送信先を特定する。`},
{target:`Same-origin policy`, content:`ウェブブラウザーのセキュリティ機能の一つであり、異なるオリジン（ドメイン、プロトコル、ポート）間のリソースアクセスを制限するポリシー。<br>JavaScriptが異なるオリジンからのリソースにアクセスすることを防ぎ、ウェブアプリケーションのセキュリティを強化。同一生成元ポリシーに違反するリクエストは、ブラウザーによってブロックされる。`},
{target:`Proxy`, content:`クライアントとサーバーの間に存在する中間サーバーのこと。<br>クライアントからのリクエストを受け取り、そのリクエストをサーバーに転送する。サーバーからのレスポンスも同様にプロキシを介してクライアントに転送される。プロキシは、セキュリティ、パフォーマンス、アクセス制御などの目的で使用される。<br>実現手段例<br>開発時：<br>&emsp;・フレームワークのAPI関連の機能を用いる（create-react-appに採用されるproxyオプションの利用）<br>&emsp;&emsp;package.jsonのproxyプロパティ設定 → 自動的にProxyを実装<br>&emsp;&emsp;'proxy': 'http://localhost:8000'（開発時のみ利用可能）<br>デプロイ時：<br>&emsp;・Expressで静的ファイルを配信しつつ、同じサーバーでhttp-proxy-middlewareなどを用いてProxyとして機能させる<br>&emsp;・nginxなどをProxyとして設置して、そこにAPIを集約する`},
{target:`http-proxy-middleware`, content:`Node.jsのHTTPサーバーで使用されるミドルウェアで、HTTPリクエストを別のサーバーにプロキシするための機能を提供。<br>開発中のウェブアプリケーションやAPIのローカルサーバーが外部のAPIやサービスにアクセスする際、リクエストを透過的にプロキシすることができる。CORSの回避やリバースプロキシの設定、開発時のローカル開発環境の構築などに役立つ。<br>読み込んだミドルウェアでcreateProxyMiddlewareを利用して作成したProxyを/apiに紐づける。createProxyMiddlewareの引数にtargetプロパティでProxy先のOriginを指定する。フロントエンドを配信するサーバーをProxyサーバー兼静的ファイル配信サーバーとすることで、APIと静的ファイル（React）が同じオリジンを持つようになる。<br>ExpressをAPI Proxyサーバー兼静的ファイル配信サーバーにするコード例<br>const { createProxyMiddleware } = require('***-***-***');<br>const express = require('express');<br>const app = express();<br>app.use(<br>&emsp;'/api',<br>&emsp;createProxyMiddleware({ → APIサーバーをlocalhost:8000で動かす<br>&emsp;&emsp;target: 'httep://localhost:8000' → Proxy先のOriginの指定<br>&emsp;})<br>);<br>// 静的ファイルを配信・・・`},
{target:`createProxyMiddleware`, content:`Expressアプリケーションで使用されるミドルウェアの1つであり、HTTPリクエストを別のサーバーにプロキシするための機能を提供。<br>このミドルウェアを使用すると、Expressアプリケーション内でリクエストを受け取り、そのリクエストを別のサーバーに転送することができる。Expressアプリケーションが外部のAPIやサービスにアクセスする際、リクエストを透過的にプロキシすることができる。<br>ExpressをAPI Proxyサーバー兼静的ファイル配信サーバーにするコード例<br>const { *** } = require('http-proxy-middleware');<br>const express = require('express');<br>const app = express();<br>app.use(<br>&emsp;'/api',<br>&emsp;***({ → APIサーバーをlocalhost:8000で動かす<br>&emsp;&emsp;target: 'httep://localhost:8000' → Proxy先のOriginの指定<br>&emsp;})<br>);<br>// 静的ファイルを配信・・・`},
{target:`nginx`, content:`高性能なオープンソースのWebサーバーソフトウェア。<br>軽量かつ高速で、静的コンテンツの配信やリバースプロキシ、負荷分散などの機能を提供。動的なWebページやアプリケーションのサポートする。多くの場合、ウェブサイトやウェブアプリケーションのホスティングに使用される。アプリケーションサーバーと別に、Proxyサーバーを用意できる。SPAをサーバーにデプロイする際、前段に配置し、アクセスを振り分けることができる。<br>upstream api {<br>&emsp;server localhost:30001;<br>}<br>location /api {<br>&emsp;proxy_pass http://api;<br>}<r>location / {<br>&emsp;try_files $uri /index.html;<br>&emsp;expires -1;<br>}`},
{target:`React useEffect`, content:`Reactのフック。特定の条件に当てはまったタイミングで与えた関数を実行する関数。<br>第１引数は実行する関数を、第２引数で実行する条件を指定する。第２引数に空の配列を渡すとコンポーネントがマウントされた時に一度だけ実行することを表す。<br>import { useState, *** } from 'react';<br>…<br>const [counter, setCounter] = useState(0); → counterとsetCounter（関数）の2つの変数を宣言（初期値 0）<br>***(() => { → 第１引数の関数定義（副作用）<br>&emsp;getUsers() →  非同期関数で、ユーザーのデータを取得する関数<br>&emsp;&emsp;.then((data) => { → getUsers()の結果が成功した場合に実行される処理<br>&emsp;&emsp;&emsp;const users = data.users.map((user) => user.name);<br>&emsp;&emsp;&emsp;return users;<br>&emsp;&emsp;})<br>&emsp;&emsp;.then((users) => setUsers(users)) → 前の.then()の結果で得られたusers配列を、ReactのsetUsers関数でセット<br>&emsp;&emsp;.catch((error) => console.error(error));<br>}, [counter]); → 第２引数にcounterを渡す<br>return (<br>&emsp;&lt;button onClick={() => setCounter(counter + 1)}&gt;更新&lt;/button&gt; → JSX構文で、button要素を返す<br>);`},
{target:`React Hooks`, content:`関数コンポーネント内で状態管理や副作用の処理を提供。<br>クラスコンポーネントを使用せずに、よりシンプルで可読性の高いコードを書くことが可能。useState、useEffect、useContextなどがあり、それぞれ状態管理、副作用の実行、コンテキストの使用などに使用。`},
{target:`Client Side Routing`, content:`ウェブアプリケーションにおいて、ブラウザ上で動的にページ遷移を管理する技術。<br>&lt;特徴&gt;<br>・シングルページアプリケーション（SPA）：一般的にSPAで使用。ユーザーがページ間を移動する際に、サーバーから新しいページを読み込む代わりに、JavaScriptでコンテンツを動的に切り替える<br>・URLの管理：ブラウザのURLを変更しながら、ページを動的に更新。ユーザーはブラウザの戻る・進むボタンを使ってナビゲートできる<br>・History APIの利用：history.pushStateやhistory.replaceStateなどのHistory APIを利用して、ブラウザの履歴を管理<br>・パフォーマンスの向上：サーバーから完全な新しいページを取得するのではなく、必要なデータだけを取得して表示を更新するため、ページ遷移が速くなり、ユーザー体験が向上<br>・代表的なライブラリ：React Router（React用）、Vue Router（Vue.js用）、Angular Router（Angular用）など`},
{target:`History API`, content:`ブラウザの履歴（history）を操作するためのAPIで、JavaScriptを使用して動的にページ遷移を管理するための手段を提供。<br>SPA（Single Page Application）や動的なウェブアプリケーション開発において、ブラウザの履歴とURLの管理を強力にサポートする重要な技術。主にクライアントサイドルーティングにおいて使用。<br>&lt;主な機能&gt;<br>・履歴の操作：ブラウザの履歴（ページ遷移の履歴：ページの追加、置き換え、移動、戻る、進むなど）を操作可能<br>・URLの変更：履歴を操作することで、URLが変更され、ブラウザのアドレスバーに新しいURLが表示。ユーザーがブラウザの戻る・進むボタンを使用して、ページ間を移動できるようになる<br>・履歴スタックの管理：履歴スタックには、ユーザーが訪れたページのURLが保持され、ブラウザのナビゲーション（戻る・進む）時に使用。JavaScriptから履歴スタックを制御し、動的なページ遷移を管理できる`},
{target:`history.pushState`, content:`History APIの一部であり、ブラウザの履歴スタックに新しいエントリを追加するためのメソッド。<br>クライアントサイドでのページ遷移を管理し、履歴のスタックに追加することができる。動的なWebアプリケーションやSPAでのページ遷移の管理が柔軟に行える。<br>&lt;主な役割&gt;<br>・履歴の追加：新しい履歴エントリをブラウザの履歴スタックに追加。ブラウザのアドレスバーのURLが変更され、履歴に新しいページのURLが追加<br>・URLの変更：URLを動的に変更。ユーザーがブラウザの戻る・進むボタンを使用して、ページ間を移動できるようになる<br>・状態オブジェクトの管理：3つの引数を受け取り、第１引数には新しい履歴エントリの状態を示すオブジェクト、第２引数にはタイトル（現在は無視されることが多い）、第三引数には新しいURLを指定`},
{target:`history.replaceState`, content:`WebブラウザのHistory APIの一部で、現在のブラウザ履歴のエントリーを新しい状態と置き換えるためのメソッド。<br>このメソッドを使用すると、ブラウザのURLや履歴を更新することができ、新しいページを追加せずに現在のページの状態を変更できる。<br>***.***(state, title, url);<br>state：保存する任意のJavaScriptオブジェクト。history.stateを通じてアクセスできる<br>title：履歴エントリーのタイトル。ほとんどのブラウザはこのパラメータを無視する<br>url：履歴エントリーに関連付ける新しいURL。現在のオリジンと同じである必要がある`},
{target:`React Router(react-router-dom)`, content:`Reactアプリケーションでのルーティングを実現するためのライブラリ。<br>URLのパスに応じて異なるコンポーネントを表示するシングルページアプリケーション（SPA）を簡単に構築できる。<br>&lt;主な機能と特徴&gt;<br>・宣言的ルーティング：JSX内でルートを定義することで、URLに基づいて表示するコンポーネントを宣言的に指定できる<br>・ネストされたルート：ルートをネストし、複雑な階層構造を持つページ遷移を実現できる<br>・動的ルーティング：URLパラメータやクエリパラメータを使って動的にルートを切り替えることができる<br>・プログラム的ナビゲーション：historyオブジェクトを使用し、コードからプログラム的にページ遷移を行うことができる<br>・リダイレクト：特定の条件で他のルートにリダイレクトする機能がある<br>$ npm install ***-***-*** -w packages/frontend → インポート<br>import { BrowserRouter as Router, Routes, Route, Link } from '***-***-***';<br>import Users form './Users';<br>function Top() { → '/'のときの表示<br>&emsp;return &lt;div&gt;Top&lt;/div&gt;;<br>}<br>function App() {<br>&emsp;return (<br>&emsp;&emsp;&lt;Router&gt;<br>&emsp;&emsp;&emsp;&lt;Routes&gt;<br>&emsp;&emsp;&emsp;&emsp;{/* /users の時に表示するコンポーネントを設定 */}<br>&emsp;&emsp;&emsp;&emsp;&lt;Route path='/users' element={&lt;Users /&gt;} /&gt;<br>&emsp;&emsp;&emsp;&emsp;{/* /の時に表示するコンポーネントを設定 */}<br>&emsp;&emsp;&emsp;&emsp;&lt;Route path='/' element={&lt;Top /&gt;} /&gt;}<br>&emsp;&emsp;&emsp;&lt;/Routes&gt;<br>&emsp;&emsp;&lt;/Router&gt;<br>&emsp;);<br>}<br>export default App;`},
{target:`React Link`, content:`React Routerの一部で、Reactアプリケーション内でクライアントサイドのナビゲーションを実現するためのコンポーネント。<br>HTMLの<a>タグに似てるが、ページのリロードを発生させずに、指定されたパスに遷移。<br>&lt;特徴&gt;<br>・クライアントサイドのナビゲーション：ページの再読み込みを伴わずにURLを変更<br>・宣言的ナビゲーション：JSX内でナビゲーションリンクを簡単に定義<br>// …<br>function App() {<br>&emsp;return (<br>&emsp;&emsp;&lt;Router&gt;<br>&emsp;&emsp;&emsp;{/* ページ上部にナビゲーションリンクを設置 */}<br>&emsp;&emsp;&emsp;&lt;nav&gt;<br>&emsp;&emsp;&emsp;&emsp;&lt;ul&gt;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&lt;li&gt;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&lt;*** to='/'&gt;Top&lt;/***&gt;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&lt;/li&gt;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&lt;li&gt;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&lt;*** to='/users'&gt;Users&lt;/***&gt;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&lt;/li&gt;<br>&emsp;&emsp;&emsp;&emsp;&lt;/ul&gt;<br>&emsp;&emsp;&emsp;&lt;/nav&gt;<br>&emsp;&emsp;&lt;Routes&gt;<br>// …`},
{target:`フロントエンドアプリケーション デプロイ`, content:`開発用のサーバーはそのまま本番に利用しない（開発時にしか利用しないでバック用のコードやホットリロードなど含むため）。<br>本番用のコードを生成するため、フロントエンドのルート（packages/frontend）でビルドする。ビルドコマンドを呼び出すとbuildディレクトリが作成される。buildディレクトリの中身が配信用にビルドされた結果のファイルになる。<br>$ npm run build # プロジェクトルートなら npm run build -w packages/frontend`},
{target:`npm run build`, content:`npmスクリプトを使用してプロジェクトのビルドを実行するコマンド。<br>主にフロントエンドのプロジェクト（特にReactやAngularなどのSPAフレームワークで）で使用。ビルドの目的は、開発中のソースコード（主にJavaScriptやCSS、画像など）を最適化された静的ファイルに変換し、本番環境での使用に適した形式にする。<br>&lt;主な手順&gt;<br>・ソースファイルの圧縮と結合：JavaScriptやCSSなどのファイルを圧縮し、必要に応じて結合する<br>・最適化：画像の圧縮、ソースマップの生成など、パフォーマンスを向上させるための最適化処理を実行<br>・静的ファイルの生成：最終的な静的ファイル（HTML、CSS、JavaScript、画像など）を生成し、指定された出力ディレクトリに配置する<br>&lt;具体的な利用例&gt;<br>・Reactプロジェクト：Reactアプリケーションを本番環境で実行する準備が整った静的ファイル群を生成。ファイルサイズが最小限に抑えられ、アプリケーションの読み込み速度が向上<br>・Angularプロジェクト：Angular CLIを使用している場合も同様で、ng buildというコマンドがこれに相当する`},
{target:`npm run server`, content:`プロジェクトの特定のサーバーを起動するための汎用的な方法を提供。<br>一般的には開発者が定義したカスタムサーバーを起動するために使用。プロジェクトに含まれるサーバーのエントリーポイントが実行される。プロジェクトのpackage.jsonファイル内で定義されたスクリプト名に対応する。'scripts'セクションで'server'という名前で定義されている場合、そのスクリプトを実行する。<br>&lt;用途&gt;<br>・バックエンドサーバーの起動：ExpressやKoaなどのNode.jsベースのバックエンドサーバーを起動するために使用されることがある<br>・APIサーバーの起動：RESTful APIやGraphQL APIを提供するサーバーを起動するために使用される<br>・カスタムの開発サーバー：開発環境で特定の設定を持つカスタムサーバーを起動するためにも利用される`},
{target:`静的ファイル`, content:`サーバー側で生成や変更が行われず、そのままクライアントに配信されるファイル。<br>これらのファイルは一度作成されると、リクエストごとに再生成されることなく、クライアントに提供される。HTMLファイル、CSSファイル、JavaScriptファイル、画像ファイルなど。<br>&lt;特徴&gt;<br>・変更されない：サーバー上で再生成や変更が行われないため、リクエストごとに同じ内容が提供<br>・キャッシュ可能：ブラウザやCDN（コンテンツデリバリーネットワーク）によってキャッシュされやすい<br>・高速な配信：再生成が不要なため、サーバーの負荷が低く、高速にクライアントに配信できる<br>&lt;使用例&gt;<br>・ウェブサイトのリソース：一般的なウェブサイトでは、スタイルシートやスクリプト、画像などが静的ファイルとして配信される<br>・CDNを通じた配信：多くのウェブサイトでは、静的ファイルをCDNに置き、地理的に分散したサーバーから高速に配信する`},
{target:`サーバーの種類・役割`, content:`backendのサーバー<br>&emsp;Expressを中心にしたAPIサーバー<br>&emsp;Redisとやりとりする<br>frontendのサーバー<br>&emsp;Expressを中心にしたProxy・静的ファイル配信サーバー<br>&emsp;別途backendの前段に配置するイメージ<br>&emsp;開発時はcreate-react-appに内蔵されているサーバーを利用`},
{target:`配信用サーバー`, content:`Node.jsを使用して静的ファイルや動的コンテンツをクライアントに配信するためのサーバー。<br>HTML、CSS、JavaScript、画像、APIレスポンスなどが含まれる。シンプルなウェブサイトから複雑なウェブアプリケーションまで、さまざまな用途に使用。Node.jsではExpressとhttp-proxy-middlewareを組合せ作成し、起動スクリプトをpackages/frontend/package.jsonに追記する（他にフレームワークにはKoaやHapiなどがある）。<br>{<br>&emsp;'server': 'node server.js'<br>}`},
{target:`Express app.get('/&ast;'`, content:`Express.jsで定義されるルートパスのハンドラー。<br>ワイルドカードを含むパスパターンで、全てのリクエストにマッチします。つまり、どのようなパスでのリクエストでもこのハンドラーが実行される。この関数より先に設定されている以外のすべてのGETリクエストに対してindex.htmlを返すように設定できる。`},
{target:`Next.js`, content:`Vercelによって開発されているReactを包括したフレームワーク。<br>Webアプリケーションやサイトの開発を簡素化し、パフォーマンスの最適化やSEO対策を効果的に行うための強力なフレームワーク。JavaScriptは取得完了まで実行できないが、サーバーサイドレンダリング（SSR）とSGの中間のようなIncremental Static Regeneration(ISR)の機能を実装。デフォルトでSSRをサポートし、初回のページ表示の速度を向上させます。これにより、SEO向上やパフォーマンスの向上が期待できる。また、静的ファイル生成や自動ルーティング、APIルートを提供。`},
{target:`Static Generation（SG）`, content:`Next.jsで提供される一種のページレンダリング方法。<br>事前に静的なHTMLを作成しておくことで、都度SSR時にかかってしまう計算コストを省ける技術。さらに静的なリソースとなることで、CDNに載せてより高速にユーザーへリソースを届けることが可能。静的コンテンツや動的なコンテンツを柔軟に組み合わせたり、ページのパフォーマンスを最適化したりするために非常に有用な手法。<br>&lt;主な特徴&gt;<br>・ビルド時にHTMLを生成：静的なページをビルド時に事前に生成し、その結果をキャッシュする。初回のアクセス時にサーバー側でのレンダリングが不要になり、高速なページロードが可能になる<br>・再生成オプション：必要に応じ、ページの再生成をトリガーすることができる。例えば、新しいコンテンツが追加されたときや定期的にページを更新したい場合に、静的ページを再生成できる<br>・SEO向上：静的生成されたページは、通常のHTMLとしてクローラーや検索エンジンによって容易にインデックスされる。SEO（検索エンジン最適化）の観点からも優れた効果を発揮<br>・CDNキャッシュの活用：静的ファイルはCDN（コンテンツデリバリーネットワーク）によってキャッシュされ、全世界のユーザーに高速に配信されるため、パフォーマンスが向上`},
{target:`Incremental Static Regeneration（ISR）`, content:`Next.jsで提供される静的生成（Static Generation）の一種。<br>静的サイトや動的な要素を効果的に組み合わせ、ユーザー体験を最適化するための強力なツール。<br>&lt;主な特徴&gt;<br>・部分的な再生成：静的に生成されたページを部分的に更新する機能。特定のページだけを再生成することができ、他のページはキャッシュされたままにすることが可能<br>・リクエスト時の再生成：ユーザーがページにアクセスした際に、リクエストをトリガーにしてページの一部または全体を再生成できる。コンテンツの最新化や動的な情報の反映を容易にする<br>・自動化と設定の柔軟性：ビルド時に静的ページを生成し、必要に応じて再生成するタイミングや条件を細かく設定できる。定期的な更新や特定のイベント後にページを更新することが可能<br>・パフォーマンスの最適化：静的ファイルを利用しながらも動的なコンテンツをリアルタイムに反映するため、パフォーマンスを向上。CDNやキャッシュを活用することで、全世界のユーザーに迅速に最新のコンテンツを提供できる`},
{target:`path`, content:`標準モジュール。ファイルやディレクトリパスなどのユーティリティ機能。`},
{target:`http/https`, content:`標準モジュール。http/httpsサーバーやクライアントの機能。<br>const http = require('http');<br>http → httpサーバーの生成（例：3000番ポートをlistenするHTTPサーバー）。<br>&emsp;.createServer((req, res) => {<br>&emsp;&emsp;res.write('hello world');<br>&emsp;&emsp;res.end();<br>&emsp;})<br>&emsp;.listen(3000) `},
{target:`os`, content:`標準モジュール。CPUの数やホスト名などOS関連情報の取得。`},
{target:`child_process`, content:`標準モジュール。子プロセス関連の機能。`},
{target:`cluster.worker_threads`, content:`標準モジュール。マルチコア、プロセスを利用するための機能。`},
{target:`crypto`, content:`標準モジュール。OpenSSLのハッシュや暗号・署名や検証などの暗号化の機能。`},
{target:`assert`, content:`標準モジュール。アサーション（変数や関数の検証）の機能。`},
{target:`コンテキスト`, content:`実行される場所。thisの値に影響を与える。`},
{target:`関数コンテキスト`, content:`関数内での this の値は、関数の呼び出し方によって異なる。<br>関数の呼び出し時に this の値を特定の値に設定するには、call() またはapply()を使用する。`},
{target:`ランタイム`, content:`実行環境。`},
{target:`同期処理`, content:`同時に1つのタスクしか実行されない。`},
{target:`非同期処理`, content:`同時に複数のタスクを処理する。`},
{target:`イベント駆動形`, content:`発行されるイベントを下敷きにさまざまな処理を行う特徴。`},
{target:`Non-Blocking I/O`, content:`I/O（入出力）をブロッキングしないこと。`},
{target:`I/O(Input/Output)`, content:`入出力。`},
{target:`キュー`, content:`先頭が常に最も古い要素になるデータ構造で、新しい要素は必ず末尾に追加される。<br>取り出すときは常に先頭の最も古い要素から取り出される。`},
{target:`イベントループ`, content:`プログラムが新たなイベントを待ち続ける状態。`},
{target:`アイドル`, content:`使用されていない、何の処理も行っていない、すぐ使用できるよう待機などの状態。`},
{target:`スレッド`, content:`並行処理に対応したマイクロプロセッサ（CPU/MPU）およびオペレーティングシステム（OS）におけるプログラムの最小の実行単位。`},
{target:`シングルスレッド`, content:`プログラムの処理の流れが一本のみである状態。`},
{target:`マルチスレッド`, content:`一つのコンピュータプログラムを実行する際に、複数の処理の流れを並行して進めること。<br>また、そのような複数の処理の流れ。`},
{target:`プロセス`, content:`実行されているプログラムを管理する単位。`},
{target:`C10K問題`, content:`Apache HTTP ServerなどのWebサーバソフトウェアとクライアントの通信において、クライアントが約1万台に達すると、Webサーバーのハードウェア性能に余裕があるにもかかわらず、レスポンス性能が大きく下がる問題。<br>Apacheはクライアントの接続1つ1つに対してプロセスを生成する仕様となっている。そのため大量のクライアントから接続があった場合、その数だけプロセスを生成しなければならない。しかし、WindowsあるいはLinuxなどのUNIX系OSでは、同時に起動できるプロセスに32767(2^15-1)個の制限がある。この制限を超えるとプロセスを新規生成することができなくなるため、既にあるリクエストの処理が終わるまで新たな接続は待たなければならない。回避には、サーバーサイドでNode.jsなどの駆動方式を持ったソフトウェアを使用する。`},
{target:`バンドル`, content:`複数のファイルを一つにまとめること。<br>単体でも提供可能な製品やサービスを、複数組み合わせてセットで販売したり、別の製品やサービスに付属して販売、提供すること。`},
{target:`バンドラー`, content:`ファイルをバンドルするツールやソフト。`},
{target:`パッケージ`, content:`一つのソフトウェアを構成する実行プログラムやソースコード、設定ファイル、データファイル、ドキュメントなどを特定の形式の圧縮ファイルなどにまとめたもの。`},
{target:`パッケージマネージャー`, content:`リポジトリに接続してパッケージの一覧を取得し、利用者が指示したパッケージを取り寄せて自動的に展開、導入（インストール）して実行可能な状態にする。`},
{target:`リポジトリ`, content:`ソフトウェア開発などに用いるバージョン管理システムやプロジェクト管理システムなどで、プロジェクトを構成するプログラムのソースコードやドキュメント、関連する各種のデータやファイルなどを一元的に管理する格納場所。`},
{target:`トランスパイル`, content:`あるプログラミング言語で書かれたプログラムを、別のプログラミング言語のプログラムに変換すること。`},
{target:`SSR(Server Side Rendering)`, content:`フロントエンドで生成されるページを、サーバーサイドで事前にレンダリングしてHTMLとして準備する。`},
{target:`レンダリング`, content:`何らかのデータ形式やデータ構造で記述された描画内容を表すデータ群をソフトウェアが読み込み、内容を解釈して画像や動画、音声などを生成する。結果をそのまま即座に画面に表示することを指すが、生成結果を何らかのデータ形式でファイルなどに記録・保存したり、ネットワークを介して別のコンピュータに送信・配信することを含む場合もある。`},
{target:`BFF(Backend For Frontend)`, content:`フロントエンドのために複数のAPIなどを束ねる役割を持つバックエンド。`},
{target:`コンテキストスイッチ`, content:`コンピュータの処理装置（CPU）が現在実行している処理の流れ（プロセス、スレッド）を一時停止し、別のものに切り替えて実行を再開すること。<br>あるプロセスを実行している最中に、処理を中断してCPU内部のレジスタの状態などを特定のメモリ領域などに保存し、同じように途中で中断されていた別のプロセスの実行状態を読み込んで処理を再開する。複数のプロセスを並行に実行することができる。`},
{target:`モジュール`, content:`機能単位、交換可能な構成部分などを意味する。<br>機器やシステムの一部を構成するひとまとまりの機能を持った部品で、システム中核部や他の部品への接合部（インターフェース）の仕様が明確に定義され、容易に追加や交換ができるようなもののことを指す。`},
{target:`シングルトン`, content:`オブジェクト指向プログラミングにおけるクラスのデザインパターンの一つ。<br>実行時に一つしかインスタンスを作ることができないように設計。プログラム上では常に同一のインスタンスを参照するように強制することができる。`},
]
